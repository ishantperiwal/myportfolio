<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GsLB Model Viewer - Orthographic with Ellipse</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="baseScreenshot/base.png" as="image">
    <link rel="prefetch" href="OS/index.html">
    <link rel="preload" href="hdri/nightsky.hdr" as="fetch" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Custom styles for the 3D canvas and file input */

        #startup-overlay {
            position: fixed;
            inset: 0; /* A modern shorthand for top, right, bottom, left = 0 */
            background-color: #000;
            z-index: 10000; /* Ensures it's on top of all other content */
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, rgb(15, 15, 15) 0%, rgb(0, 0, 0) 100%);
        }

        #startup-overlay::after {
            content: ''; /* Required to generate the pseudo-element */
            position: absolute;
            inset: 0; /* Makes it cover the parent overlay perfectly */
            pointer-events: none; /* Allows clicks to go through to the button */

            /* Re-using the same SVG noise filter from your .noise-layer */
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");

            /* Control the intensity of the grain here */
            opacity: 0.07;
        }

        /* ADDED: A new class to define the final "visible" state for the animation */

        #startup-overlay.visible #startup-button {
            transform: scale(1);
            opacity: 1;
        }

        /* MODIFIED: Start the button slightly smaller for the scale-up effect */
        #startup-button {
            width: 530px;
            height: 530px;
            cursor: pointer;
            transform: scale(0.86);
            opacity: 0;
            /* Use a longer, smoother transition for the initial reveal */
            transition: transform 1.2s cubic-bezier(0.3, 0.3, 0.2, 1), opacity 1.2s ease-out;
        }


        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from appearing */
            transition: background-color 0.3s; /* Smooth color transition */
            background-color: #242424; /* New default background color */
        }
        #viewer-canvas {
            display: block;
            width: 100%;
            height: 100%;
            outline: none;
        }
        /* The CSS3DRenderer will have its own container */
        #css3d-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40; /* Layer between reveal layer and UI */
        }
        #css3d-container iframe {
              pointer-events: none;  /* Disables mouse interactions */
              border-radius: 0px;               /* Ensures sharp, square corners */
            }
        /* Hide the default file input */
        #model-input {
            display: none;
        }
        /* Style the color pickers */
        #bg-color-picker, #grid-color-picker, #ellipse-color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 0.5rem; /* rounded-lg */
            cursor: pointer;
            background-color: transparent;
        }
        #bg-color-picker::-webkit-color-swatch, #grid-color-picker::-webkit-color-swatch, #ellipse-color-picker::-webkit-color-swatch {
            border-radius: 0.5rem;
            border: 2px solid #e5e7eb; /* gray-200 */
        }
        #bg-color-picker::-moz-color-swatch, #grid-color-picker::-moz-color-swatch, #ellipse-color-picker::-moz-color-swatch {
            border-radius: 0.5rem;
            border: 2px solid #e5e7eb; /* gray-200 */
        }
        /* --- Animated Noise Layer --- */
        @keyframes animateNoise {
          0% { transform: translate(0, 0); }
          10% { transform: translate(-5%, -5%); }
          20% { transform: translate(-10%, 5%); }
          30% { transform: translate(5%, -10%); }
          40% { transform: translate(-5%, 15%); }
          50% { transform: translate(-10%, 5%); }
          60% { transform: translate(15%, 0); }
          70% { transform: translate(0, 10%); }
          80% { transform: translate(-15%, 0); }
          90% { transform: translate(10%, 5%); }
          100% { transform: translate(5%, 0); }
        }
        .noise-layer {
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            pointer-events: none; /* Make it click-through */
            z-index: 50; /* Above 3D scene and CSS3D, below UI */
            opacity: 0.05; /* Default opacity */
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            animation: animateNoise 1s steps(4) infinite; /* Default speed */
        }
        #ishant-text {
            font-family: 'Aldrich', sans-serif;
            font-size: 12rem; /* Make the text larger */
            margin-top: 9rem; /* Push the text down */
        }
        #placeholder-iframe-container {
            position: absolute;
            top: -9999px; /* Hide the iframe off-screen */
            left: -9999px;
        }
        /* Message Box Styling */
        #message-box {
            transition: opacity 0.5s, transform 0.5s;
        }
        /* NEW: Styles for 3D text */
        .text-container {
            font-family: 'Aldrich', sans-serif;
            color: white;
            transform: skewX(-10deg);
            line-height: 1.1;
            white-space: nowrap;
            user-select: none;
            pointer-events: auto; /* Make text interactive */
        }
        #left-text-container h1 {
            font-size: 72px;
            margin-bottom: 16px;
            font-weight: 700;
        }
        #left-text-container p {
            font-size: 24px;
            color: #ACACAC;
        }
        #right-text-container {
            display: flex;
            flex-direction: column;
            text-align: right;
            gap:24px;
        }
        #right-text-container a {
            font-size: 40px;
            font-weight: 700;
            text-decoration: none;
            color: #ACACAC;
            margin-bottom: 5px;
            transition: transform 0.2s ease-out, color 0.2s ease-in-out;
        }
        #right-text-container a:hover {
            transform: translateX(-15px);
            color: white;
        }
        /* NEW: Styles for the long press indicator */
        #long-press-indicator {
            position: fixed;
            /* Center the SVG on the cursor */
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
            display: none; /* Start hidden */
            overflow: visible;
        }
        #long-press-indicator svg {
            /* This rotates the starting point of the stroke to the top */
            transform: rotate(-90deg);
        }

        #iframe-stroke {
        /* Dimensions should match the iframe's resolution */
        width: 1679px;
        height: 1292px;
        /* Create the visual stroke */
        border: 24px solid black; /* Adjust thickness and color as needed */
        box-sizing: border-box; /* Ensures border is included in the dimensions */
        background: transparent;
        pointer-events: none; /* Make it click-through */
    }

    </style>
</head>
<body class="text-white">

  <div id="startup-overlay">
      <img id="startup-button" src="OS/boot/1.png" alt="Start Experience">
  </div>



    <!--
      NEW: Long press indicator element.
      The initial size and stroke are set here, but controlled by the global JS variables.
      If you change the INDICATOR_SIZE or INDICATOR_INITIAL_STROKE in the script,
      you should update the values here to match for consistency.
    -->
    <div id="long-press-indicator">
        <svg width="80" height="80" viewBox="0 0 80 80" style="overflow: visible;">
            <circle cx="40" cy="40" r="38" stroke="white" stroke-width="4" fill="none" />
        </svg>
    </div>


    <div style="position: absolute; top: -9999px; left: -9999px;">
      <div id="iframe-stroke"></div>
        <div id="left-text-container" class="text-container">
            <h1>ISHANT</h1>
            <p>PRODUCT DESIGN</p>
        </div>
        <div id="right-text-container" class="text-container">
            <a href="#">CONTACT</a>
            <a href="#">ABOUT</a>
            <a href="#">WORK</a>
            <a href="#">RESUME</a>
        </div>
    </div>


    <div id="background-text-layer" class="absolute inset-0 z-10 flex justify-center items-start pt-24 pointer-events-none">
        <h1 id="ishant-text" class="text-9xl font-black text-white opacity-10 select-none"></h1>
    </div>

    <div class="noise-layer"></div>

    <div id="viewer-container" class="w-screen h-screen absolute top-0 left-0 z-20">
        <canvas id="viewer-canvas"></canvas>
    </div>

    <div id="css3d-container"></div>

    <div id="placeholder-iframe-container"></div>

    <div class="absolute top-0 right-0 p-6 w-full flex flex-col sm:flex-row justify-between items-start z-[60]">
        <div id="top-left-ui" class="pointer-events-auto" style="display:none;">
            <h1 id="title-text" class="text-2xl font-bold text-white drop-shadow-sm">3D Model Viewer</h1>
            <p id="instructions" class="text-gray-300 drop-shadow-sm max-w-sm">
                Click the button to load a <code id="code-text-1" class="bg-gray-700 text-pink-400 px-1 rounded-md">.glb</code> or <code id="code-text-2" class="bg-gray-700 text-pink-400 px-1 rounded-md">.gltf</code> file from your computer.
            </p>
        </div>

        <div class="ml-auto flex items-start space-x-2 pointer-events-auto" style="display:none;">
            <button id="toggle-ui-btn" class="p-2 rounded-lg bg-white/20 backdrop-blur-sm shadow hover:bg-white/30 transition-colors">
                <svg id="eye-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-eye"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                <svg id="eye-icon-closed" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-eye-off hidden"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>
            </button>

            <div id="ui-controls-container" class="flex items-start flex-wrap gap-4">
                 <div class="flex flex-col items-center space-y-1 bg-white/20 backdrop-blur-sm p-3 rounded-lg shadow">
                    <label for="object-name-input" id="object-name-label" class="text-sm font-medium text-gray-300">Object Name for Glass</label>
                    <input type="text" id="object-name-input" placeholder="e.g., 'Screen'" class="w-32 px-2 py-1 border border-gray-500 rounded-md text-sm bg-white/10 text-white">
                    <button id="apply-glass-btn" class="mt-2 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md text-sm transition-colors">Apply Effect</button>
                </div>
                 <div class="flex flex-col items-center space-y-1 bg-white/20 backdrop-blur-sm p-3 rounded-lg shadow">
                    <label for="noise-opacity-slider" id="noise-opacity-label" class="text-sm font-medium text-gray-300">Noise Opacity</label>
                    <input type="range" id="noise-opacity-slider" min="0" max="0.5" step="0.01" value="0.04" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    <label for="noise-speed-slider" id="noise-speed-label" class="text-sm font-medium text-gray-300 mt-2">Animation Speed</label>
                    <input type="range" id="noise-speed-slider" min="0.1" max="2" step="0.1" value="1" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                </div>
                <div id="grid-controls" class="flex flex-col items-center space-y-1 bg-white/20 backdrop-blur-sm p-3 rounded-lg shadow">
                    <label class="text-sm font-medium text-gray-300">Grid Controls</label>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="grid-width-slider" class="text-xs text-gray-300 flex-1">Grid Width (<span id="grid-width-value">22</span>)</label>
                        <input type="range" id="grid-width-slider" min="1" max="50" step="1" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="grid-height-slider" class="text-xs text-gray-300 flex-1">Grid Height (<span id="grid-height-value">11</span>)</label>
                        <input type="range" id="grid-height-slider" min="1" max="50" step="1" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="square-size-slider" class="text-xs text-gray-300 flex-1">Square Size (<span id="square-size-value">1.0</span>)</label>
                        <input type="range" id="square-size-slider" min="0.1" max="5" step="0.1" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="grid-thickness-slider" class="text-xs text-gray-300 flex-1">Thickness</label>
                        <input type="range" id="grid-thickness-slider" min="0.01" max="0.5" step="0.01" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="grid-offset-x-slider" class="text-xs text-gray-300 flex-1">Offset X (<span id="grid-offset-x-value">0.0</span>)</label>
                        <input type="range" id="grid-offset-x-slider" min="-10" max="10" step="0.1" value="0.0" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="grid-offset-z-slider" class="text-xs text-gray-300 flex-1">Offset Z (<span id="grid-offset-z-value">0.0</span>)</label>
                        <input type="range" id="grid-offset-z-slider" min="-10" max="10" step="0.1" value="0.0" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full mt-2">
                        <label for="grid-color-picker" class="text-xs text-gray-300 flex-1">Color</label>
                        <input type="color" id="grid-color-picker">
                    </div>
                </div>
                <!-- START: Updated Ellipse Controls -->
                <div id="ellipse-controls" class="flex flex-col items-center space-y-1 bg-white/20 backdrop-blur-sm p-3 rounded-lg shadow">
                    <label class="text-sm font-medium text-gray-300">Stroke Controls</label>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="ellipse-diameter-x-slider" class="text-xs text-gray-300 flex-1">Diameter X (<span id="ellipse-diameter-x-value">1.0</span>)</label>
                        <input type="range" id="ellipse-diameter-x-slider" min="0.1" max="2.0" step="0.01" value="1.0" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <div class="flex items-center space-x-2 w-full">
                        <label for="ellipse-diameter-y-slider" class="text-xs text-gray-300 flex-1">Diameter Y (<span id="ellipse-diameter-y-value">1.0</span>)</label>
                        <input type="range" id="ellipse-diameter-y-slider" min="0.1" max="2.0" step="0.01" value="1.0" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="ellipse-thickness-slider" class="text-xs text-gray-300 flex-1">Thickness (<span id="ellipse-thickness-value">0.1</span>)</label>
                        <input type="range" id="ellipse-thickness-slider" min="0.01" max="0.5" step="0.01" value="0.1" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="ellipse-softness-slider" class="text-xs text-gray-300 flex-1">Softness (<span id="ellipse-softness-value">0.5</span>)</label>
                        <input type="range" id="ellipse-softness-slider" min="0.01" max="1.0" step="0.01" value="0.5" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="ellipse-offset-x-slider" class="text-xs text-gray-300 flex-1">Offset X (<span id="ellipse-offset-x-value">0.0</span>)</label>
                        <input type="range" id="ellipse-offset-x-slider" min="-1.0" max="1.0" step="0.01" value="0.0" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="ellipse-offset-y-slider" class="text-xs text-gray-300 flex-1">Offset Y (<span id="ellipse-offset-y-value">0.0</span>)</label>
                        <input type="range" id="ellipse-offset-y-slider" min="-1.0" max="1.0" step="0.01" value="0.0" class="w-24 h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center space-x-2 w-full mt-2">
                        <label for="ellipse-color-picker" class="text-xs text-gray-300 flex-1">Color</label>
                        <input type="color" id="ellipse-color-picker">
                    </div>
                </div>
                <!-- END: Updated Ellipse Controls -->
                 <div class="flex flex-col space-y-2">
                    <input type="color" id="bg-color-picker" value="#363636" title="Change background color">
                    <label for="model-input" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg cursor-pointer transition-colors duration-300">
                        Load Model
                    </label>
                    <input type="file" id="model-input" accept=".glb, .gltf">
                </div>
            </div>
        </div>
    </div>

    <div id="reveal-layer" class="absolute inset-0 bg-black z-30 pointer-events-none"></div>

    <div id="message-box" class="hidden absolute top-5 left-1/2 -translate-x-1/2 p-4 rounded-lg text-white font-semibold shadow-2xl z-[70] pointer-events-none opacity-0 -translate-y-20">
        <p id="message-text"></p>
    </div>

    <audio id="boot-sound" src="OS/sfx/boot.mp3" preload="auto"></audio>

    <audio id="spacebar-sound" src="OS/sfx/spacebar.mp3" preload="auto"></audio>


    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

      let lastMouseX = 0;
       let lastMouseY = 0;
       document.addEventListener('mousemove', (e) => {
           lastMouseX = e.clientX;
           lastMouseY = e.clientY;
       })


        const overlay = document.getElementById('startup-overlay');
        const button = document.getElementById('startup-button');
        let wasClicked = false;

        overlay.style.pointerEvents = 'none';

        // Trigger the animation by adding the 'visible' class after a short delay.
        // This ensures the initial CSS state is applied before the animation starts.
        setTimeout(() => {
            overlay.classList.add('visible');
        }, 100);

        // Listen for the end of the reveal animation.
        overlay.addEventListener('transitionend', (event) => {
      if (event.propertyName === 'opacity') {
          // Wait for the 100ms delay you requested
          setTimeout(() => {
              // Make the overlay and button interactive
              overlay.style.pointerEvents = 'auto';
              button.style.transition = 'transform 0.2s ease-out';

              // Now, check if the mouse is already over the button
              const rect = button.getBoundingClientRect();
              if (
                  lastMouseX >= rect.left &&
                  lastMouseX <= rect.right &&
                  lastMouseY >= rect.top &&
                  lastMouseY <= rect.bottom
              ) {
                  // If it is, manually dispatch a 'mouseenter' event
                  // This forces the browser to trigger the hover effects and recognize the button
                  button.dispatchEvent(new MouseEvent('mouseenter', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                  }));
              }
          }, 10); // 100ms delay
      }
  }, { once: true });


        // --- Configuration ---
        const image1_url = 'OS/boot/1.png';
        const image2_url = 'OS/boot/2.png';

        // Preload the second image to prevent a flicker on click
        const preloadImage = new Image();
        preloadImage.src = image2_url;

        // --- Interactive Effects ---
        button.addEventListener('mouseenter', () => {
            if (!wasClicked) button.style.transform = 'scale(1.05)';
        });

        button.addEventListener('mouseleave', () => {
            // Revert to the base scale if the button hasn't been clicked yet
            if (!wasClicked) button.style.transform = 'scale(1)';
        });

        button.addEventListener('mousedown', () => {
            if (!wasClicked) {
                button.style.transform = 'scale(0.95)';
                // Change the image source on press
                button.src = image2_url;
            }
        });

        button.addEventListener('mouseup', () => {
            // When mouse is released, pop back to the hover scale
            if (!wasClicked) button.style.transform = 'scale(1.05)';
        });

        // --- Main Click Action ---
        button.addEventListener('click', () => {
            // This ensures the action only runs once
            if (wasClicked) return;
            wasClicked = true;

            // Lock the button in its final pressed state during the fade
            button.style.transform = 'scale(0.95)';
            button.style.cursor = 'default';

            // Send the boot message to the iframe
            const iframe = document.querySelector('#css3d-container iframe');
            if (iframe && iframe.contentWindow) {
                 iframe.contentWindow.postMessage('begin_boot', '*');
            } else {
                console.error("Could not find the iframe to send the 'begin_boot' message.");
            }

            // Start the fade-out animation after a very short delay
            // This ensures the browser has time to render the image change to 2.png
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 50);

            // After the fade animation finishes, hide the overlay completely
            overlay.addEventListener('transitionend', () => {
                overlay.style.display = 'none';
            });
        });
    });
</script>


    <script type="module">
        // Import necessary modules from three.js
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        // Import the CSS3DRenderer
        import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

        // --- NEW: Long Press Indicator Controls ---
        const INDICATOR_SIZE = 60; // Diameter of the circle in pixels
        const INDICATOR_INITIAL_STROKE = 9; // Starting stroke width
        const INDICATOR_COMPLETED_STROKE = 42; // Stroke width on successful press
        const INDICATOR_SUCCESS_SCALE = 1.3; // How much it scales on final animation
        const INDICATOR_OFFSET = { x: 0, y: 0 }; // Position offset from cursor
        const INDICATOR_ROLLBACK_DURATION = 0.3; // Duration of the cancel animation
        const INDICATOR_SUCCESS_DURATION = 0.4; // Duration of the success animation
        const INDICATOR_BOUNCE_DURATION = 0.4; // Duration of the bouncy scale animation
        const INDICATOR_BOUNCE_EASE = "elastic.out(1, 0.5)"; // Easing for the bouncy animation
        const INDICATOR_INITIAL_OPACITY = 0.7;
        const INDICATOR_COLOR = "white";

        // --- Camera and Orbit Controls ---
        const INITIAL_CAMERA_POSITION = new THREE.Vector3(2.2, 2.6, 5);
        const INITIAL_CAMERA_PAN_X = -0.95;
        const INITIAL_CAMERA_PAN_Y = -1.35;
        const INITIAL_CAMERA_ZOOM = 2.55;
        const INITIAL_MIN_ZOOM = 2.45;
        const INITIAL_MAX_ZOOM = 4.2;
        const ORBIT_LIMIT_LEFT = 36;
        const ORBIT_LIMIT_RIGHT = 48;
        const ORBIT_LIMIT_UP = 38;
        const ORBIT_LIMIT_DOWN = -10;
        const SNAP_BACK_DURATION = 0.5;
        const SNAP_BACK_EASING = "power2.out";

        // --- Frustum Controls ---
        const FRUSTUM_HEIGHT = 22;
        const NEAR_PLANE_MULTIPLIER = -5;
        const FAR_PLANE_MULTIPLIER = 5;

        // --- Boot State Controls ---
        const BOOT_STATE_DELAY = 250;
        const BOOT_ANIMATION_DURATION = 1.2;
        const BOOT_ANIMATION_EASING = "power2.inOut";
        const BOOT_CAMERA_POSITION_OFFSET = new THREE.Vector3(0, 0, 3);
        const BOOT_CAMERA_ZOOM = 3.35;
        const BOOT_CROSSFADE_DURATION = 0.5;

        // --- NEW: Blinking Layer Controls ---
        const BLINKING_LAYER_WIDTH = 210; // Width of the layer in pixels
        const BLINKING_LAYER_HEIGHT = 70;  // Height of the layer in pixels
        const BLINKING_LAYER_CORNER_RADIUS = 20; // Corner radius in pixels
        // This is now a RELATIVE offset from the center of the main interactive plane
        const BLINKING_LAYER_POSITION_OFFSET = new THREE.Vector3(1.149, -1.67, -0.03);
        const BLINKING_LAYER_GLOW_COLOR = 'rgba(230, 230, 230, 0.9)'; // Glow color
        const BLINKING_LAYER_TOTAL_BLINKS = 4; // Number of blinks in the animation
        const BLINKING_LAYER_ANIMATION_DURATION = 0.9; // Total duration of the blinking sequence
        const BLINKING_LAYER_FADE_OUT_DURATION = 0.4; // Duration of the fade-out when transitioning

        // --- Focused Camera State ---
        const FOCUSED_CAMERA_POSITION_OFFSET = new THREE.Vector3(0, 0, 3);
        const FOCUSED_CAMERA_ZOOM = 3.34;
        const FOCUSED_MIN_ZOOM = 3.34;
        const FOCUSED_MAX_ZOOM = 5.3;
        const FOCUS_ANIMATION_DURATION = 1.2;
        const FOCUS_EASING = "power2.inOut";
        const CROSSFADE_DURATION = 0.5;
        const FOCUSED_ORBIT_LIMIT_LEFT = 12;
        const FOCUSED_ORBIT_LIMIT_RIGHT = 12;
        const FOCUSED_ORBIT_LIMIT_UP = 0;
        const FOCUSED_ORBIT_LIMIT_DOWN = 0;
        // --- NEW: Focus Orbit Controls ---
        const ORBIT_SAFE_ZONE_WIDTH = 0.55; // 40% of the screen is the central safe zone
        const ORBIT_AREA_OF_EFFECT = 2.1; // Effect is contained within 90% of screen width
        const MAX_ORBIT_ANGLE = 25; // Max orbit of 25 degrees to each side

        // --- Wobble Head Controls ---
        const WOBBLE_STRENGTH = 0.3; // Radians, how far it wobbles initially
        const WOBBLE_DURATION = 1.0;  // Total duration of the wobble animation in seconds

        // --- Camera Hover Controls ---
        const HOVER_AMPLITUDE = 0.22; // How far the camera will float from center
        const HOVER_SPEED = 0.35;      // How fast the camera will float
        const HOVER_FADE_DURATION = 1.0; // Duration for hover fade in/out

        // --- Smoke Effect Controls ---
        const SMOKE_GROUP_POSITION_OFFSET = new THREE.Vector3(-0.15, 1.8, 0.13);
        const SMOKE_GROUP_ROTATION_DEGREES = { x: 0, y: 0, z: 0 }; // y-value is now an offset
        const SMOKE_GROUP_SCALE = 4.3;
        const SMOKE_GROUP_OPACITY = 0.3;
        const SMOKE_TIME_FREQUENCY = 0.5;
        const SMOKE_UV_FREQUENCY_X = 2.8;
        const SMOKE_UV_FREQUENCY_Y = 4;
        const SMOKE_LENGTH = 0.6;
        const SMOKE_COLOR = '#ffffff';

        // --- Coffee Plane Controls ---
        const COFFEE_PLANE_COLOR = '#D4BBA7';
        const COFFEE_PLANE_SCALE = 0.56;
        const COFFEE_PLANE_POSITION_OFFSET = new THREE.Vector3(-0.15, -4.29, 0.13);

        // --- Coffee Light Controls ---
        const COFFEE_LIGHT_COLOR = '#ff8c00';
        const COFFEE_LIGHT_INTENSITY = 1.8;
        const COFFEE_LIGHT_DISTANCE = 2.5;
        const COFFEE_LIGHT_POSITION_OFFSET = new THREE.Vector3(0, 0.5, 0);

        // --- Lighting Controls ---
        const HEMISPHERE_LIGHT_SKY_COLOR = 0xffffff;
        const HEMISPHERE_LIGHT_GROUND_COLOR = 0x444444;
        const HEMISPHERE_LIGHT_INTENSITY = 0.9;
        const AMBIENT_LIGHT_COLOR = 0xffffff;
        const AMBIENT_LIGHT_INTENSITY = 0;
        const HDRI_URL = 'hdri/nightsky.hdr';
        const HDRI_INTENSITY = 1.5;



        // --- Grid Controls ---
      const GRID_WIDTH = 30;
      const GRID_HEIGHT = 30;
      const SQUARE_SIZE = 0.66;
      const GRID_THICKNESS = 0.02;
      const GRID_COLOR = '#404040';
      const GRID_OFFSET_X = 0.0;
      const GRID_OFFSET_Z = -4.8;

      // --- NEW: Ellipse Controls --
      const ELLIPSE_COLOR = '#696969';
      const ELLIPSE_DIAMETER_X = 0.271;
      const ELLIPSE_DIAMETER_Y = 0.266;
      const ELLIPSE_THICKNESS = 0.40;
      const ELLIPSE_SOFTNESS = 0.28;
      const ELLIPSE_OFFSET_X = 0.0;
      const ELLIPSE_OFFSET_Y = 0.022;

        // --- Plane Controls ---
        const INTERACTIVE_URL = 'OS/index.html';
        const PLANE_RESOLUTION = { width: 1669, height: 1284 }; // original { width: 2054, height: 1580 }
        const PLANE_SCALE = 0.00165*1.234;
        const PLANE_POSITION = new THREE.Vector3(0.488, 3.50, -1.205);
        const PLANE_ROTATION_DEGREES = { x: 0, y: 0, z: 0 };
        const PLANE_CORNER_RADIUS_PX = 50;
        const PLANE_FALLBACK_COLOR = '#333333';

        // --- Texture Overlay Controls ---
        const OVERLAY_TEXTURE_URL = 'OS/frontpane.png'; // Example URL, replace with your own
        const OVERLAY_PLANE_DISTANCE = 0.07; // Distance in front of the placeholder plane
        const OVERLAY_PLANE_SCALE = 1.04;

        // --- Bee Controls ---
        const BEE_URL = 'bee.glb';
        const BEE_POSITION = new THREE.Vector3(1.2, 2.6, 0.6);
        const BEE_ROTATION = { x: 0, y: -28, z: 10 };
        const BEE_SCALE = new THREE.Vector3(0.2, 0.2, 0.2);
        const BEE_ANIMATION_SPEED = 11.5;
        const BEE_TILT_STRENGTH = 2.5;
        const BEE_MOVEMENT_RADIUS = { x: 0.4, y: 0.3, z: 0.1 };
        const BEE_IDLE_DURATION = { min: 2.0, max: 2.9 };
        const BEE_MOVE_DURATION = { min: 1.3, max: 2.5 };
        const BEE_MAX_YAW_RADIANS_PER_SEC = THREE.MathUtils.degToRad(12); // Max turn speed

        // --- 86 Body Controls ---
        const BODY86_POSITION_OFFSET = new THREE.Vector3(0, 0.01, 0);
        const BODY86_PRESS_DEPTH = 0.02;
        const BODY86_BOUNCE_ELASTICITY = 1.4;
        const BODY86_LIGHT_MAX_INTENSITY = 125.0;
        const BODY86_LIGHT_BLINK_DURATION = 0.35;
        const BODY86_LIGHT_BLINK_COUNT = 5;
        const BODY86_LIGHT_EMISSIVE_COLOR = '#ffffff';
        const BODY86_LIGHT_BASE_COLOR = '#cccccc';

        // --- NEW: Ground Light Controls ---
        const BODY86_GROUND_LIGHT_COLOR = '#ffae00';
        const BODY86_GROUND_LIGHT_MAX_OPACITY = 1;
        const BODY86_GROUND_LIGHT_SCALE = new THREE.Vector3(0.8, 2.6, 1);
        const BODY86_GROUND_LIGHT_ROTATION = THREE.MathUtils.degToRad(-30);
        const BODY86_GROUND_LIGHT_OFFSET_LEFT = new THREE.Vector3(-0.60, 0.01, 1.13);
        const BODY86_GROUND_LIGHT_OFFSET_RIGHT = new THREE.Vector3(-0.94, 0.01, 0.9);



        //const DEFAULT_GLB_URL = 'https://cdn.jsdelivr.net/gh/ishantperiwal/portfolio@672542c848d96a8d4f43b702b86492530ee1881b/models/8%20New%20flower%20STICKER%20motion%20card%20full%20scene%20material%20change.glb';
        const DEFAULT_GLB_URL = 'mainscene/scene.gltf';


        // --- Basic Scene Setup ---
        const canvas = document.getElementById('viewer-canvas');
        const css3dContainer = document.getElementById('css3d-container');
        const fileInput = document.getElementById('model-input');
        const bgColorPicker = document.getElementById('bg-color-picker');
        const instructions = document.getElementById('instructions');
        const noiseLayer = document.querySelector('.noise-layer');
        const noiseOpacitySlider = document.getElementById('noise-opacity-slider');
        const noiseSpeedSlider = document.getElementById('noise-speed-slider');
        const objectNameInput = document.getElementById('object-name-input');
        const applyGlassBtn = document.getElementById('apply-glass-btn');
        const toggleUiBtn = document.getElementById('toggle-ui-btn');
        const uiControlsContainer = document.getElementById('ui-controls-container');
        const eyeIconOpen = document.getElementById('eye-icon-open');
        const eyeIconClosed = document.getElementById('eye-icon-closed');
        const topLeftUi = document.getElementById('top-left-ui');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const revealLayer = document.getElementById('reveal-layer');
        // MODIFIED: Get grid control elements
        const gridWidthSlider = document.getElementById('grid-width-slider');
        const gridHeightSlider = document.getElementById('grid-height-slider');
        const squareSizeSlider = document.getElementById('square-size-slider');
        const gridThicknessSlider = document.getElementById('grid-thickness-slider');
        const gridColorPicker = document.getElementById('grid-color-picker');
        const gridOffsetXSlider = document.getElementById('grid-offset-x-slider');
        const gridOffsetZSlider = document.getElementById('grid-offset-z-slider');
        // NEW: Get long press indicator elements
        const longPressIndicator = document.getElementById('long-press-indicator');
        const indicatorCircle = longPressIndicator.querySelector('circle');




        let boot_sequence_finished = false;


        let scene, camera, renderer, cssRenderer, controls, loadedModel, internalLight;
        let leftTextObject, rightTextObject; // NEW: Declared in top-level scope
        let cameraGroup; // Parent group for the camera
        let hoverIntensity = { value: 0 }; // Use object for GSAP tweening
        let beeModel, beeMixer;
        let beeInitialPosition = new THREE.Vector3();
        let previousBeePosition = new THREE.Vector3();
        let beeState = 'IDLE';
        let beeStateTimer = 0;
        let beeTargetPosition = new THREE.Vector3();
        let beeIdleStartTime = 0;

        let strokeObject;


        let placeholderPlane, cssObject, textureOverlayPlane;
        let lottieHead, lottieHeadPivot;
        let smokeGroup, smokeMaterials = [];
        let keyboardKeys = [];
        let spacebarKey = null;
        let initialCameraState = {
            position: new THREE.Vector3(),
            target: new THREE.Vector3()
        };
        let focusedCameraState = {
            position: new THREE.Vector3(),
            target: new THREE.Vector3()
        };
        let initialControlLimits = {};
        let isFocused = false;
        let isInBootState = false;
        let isTransitioning = false;
        let isMouseDown = false;
        let dragHappened = false;
        let isMouseOverIframe = false; // NEW: Track if mouse is over the interactive iframe
        let focusInitialAzimuth = 0; // NEW: Base angle for focus orbit
        let focusInitialRadius = 0; // NEW: Base radius for focus orbit
        let leftTextInitialPos = new THREE.Vector3();
        let rightTextInitialPos = new THREE.Vector3();


        let mouseDownTime = 0;
        const CLICK_THRESHOLD_MS = 320;
        // NEW: Variable for the long press animation
        let longPressTween = null;


        // --- NEW: Variables for blinking layer ---
        let blinkingLayer, blinkingLayerObject;

        // --- Variables for the 86 model ---
        let body86 = null;
        let lights86Material = null;
        let body86InitialY = 0;
        let groundLightLeft, groundLightRight; // NEW: Variables for ground lights

        // NEW: Variable for the custom grid
        let gridGroup;
        // NEW: Variables for the ellipse effect
        let ellipsePlane, ellipseMaterial;


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const clock = new THREE.Clock();
        const planeNormal = new THREE.Vector3(0, 0, 1);
        const cameraDirection = new THREE.Vector3();
        let maxAnisotropy;



        const spacebarSound = document.getElementById('spacebar-sound');
        const keyboardSfxPaths = [
          'OS/sfx/keyboard/keypress_1.mp3',
          'OS/sfx/keyboard/keypress_2.mp3',
          'OS/sfx/keyboard/keypress_3.mp3',
          'OS/sfx/keyboard/keypress_4.mp3',
          'OS/sfx/keyboard/keypress_5.mp3',
          'OS/sfx/keyboard/keypress_6.mp3',
          // Add more paths as you get more sound files
      ];

        const keyboardAudioObjects = keyboardSfxPaths.map(path => {
        const audio = new Audio(path);
        audio.preload = 'auto';
        return audio;
        });


        function playRandomKeypressSound() {
        if (keyboardAudioObjects.length === 0) return; // No sounds to play

        const randomIndex = Math.floor(Math.random() * keyboardAudioObjects.length);
        const soundToPlay = keyboardAudioObjects[randomIndex];

        // Reset and play
        soundToPlay.currentTime = 0;
        soundToPlay.play().catch(e => console.log("Keypress sound blocked:", e));
        }



        // --- MODIFIED: Function to create a simple grid ---
        function updateCustomGrid() {
            if (gridGroup) {
                scene.remove(gridGroup);
                gridGroup.children.forEach(line => {
                    line.geometry.dispose();
                });
                if (gridGroup.children.length > 0) {
                     gridGroup.children[0].material.dispose();
                }
            }

            const width = parseFloat(gridWidthSlider.value);
            const height = parseFloat(gridHeightSlider.value);
            const squareSize = parseFloat(squareSizeSlider.value);
            const thickness = parseFloat(gridThicknessSlider.value);
            const color = new THREE.Color(gridColorPicker.value);

            const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });

            gridGroup = new THREE.Group();

            // Create vertical lines
            const numLinesX = Math.floor(width / squareSize);
            const halfWidth = width / 2;
            const verticalLineGeo = new THREE.PlaneGeometry(thickness, height);
            for (let i = 0; i <= numLinesX; i++) {
                const line = new THREE.Mesh(verticalLineGeo, material);
                line.position.x = -halfWidth + i * squareSize;
                gridGroup.add(line);
            }

            // Create horizontal lines
            const numLinesY = Math.floor(height / squareSize);
            const halfHeight = height / 2;
            const horizontalLineGeo = new THREE.PlaneGeometry(width, thickness);
            for (let i = 0; i <= numLinesY; i++) {
                const line = new THREE.Mesh(horizontalLineGeo, material);
                line.position.y = -halfHeight + i * squareSize; // Corresponds to Z after rotation
                gridGroup.add(line);
            }

            gridGroup.rotation.x = -Math.PI / 2;

            gridGroup.position.x = parseFloat(gridOffsetXSlider.value);
            gridGroup.position.y = -0.01;
            gridGroup.position.z = parseFloat(gridOffsetZSlider.value);

            document.getElementById('grid-width-value').textContent = width.toFixed(1);
            document.getElementById('grid-height-value').textContent = height.toFixed(1);
            document.getElementById('square-size-value').textContent = squareSize.toFixed(1);
            document.getElementById('grid-offset-x-value').textContent = gridGroup.position.x.toFixed(1);
            document.getElementById('grid-offset-z-value').textContent = gridGroup.position.z.toFixed(1);

            scene.add(gridGroup);
        }

        // --- MODIFIED: Function to create the visible ellipse stroke ---
        function createEllipseEffect() {
            const ellipseVertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const ellipseFragmentShader = `
                uniform vec3 uColor;
                uniform vec2 uDiameter;
                uniform float uThickness;
                uniform float uSoftness;
                uniform vec2 uOffset;
                varying vec2 vUv;

                void main() {
                    vec2 centeredUv = (vUv - 0.5 - uOffset) * 2.0;
                    vec2 scaledUv = centeredUv / uDiameter;
                    float dist = length(scaledUv);

                    float inner = 1.0 - uThickness;
                    float alpha = smoothstep(inner - uSoftness, inner, dist) - smoothstep(1.0 - uSoftness, 1.0, dist);

                    gl_FragColor = vec4(uColor, alpha);
                }
            `;

            ellipseMaterial = new THREE.ShaderMaterial({
                vertexShader: ellipseVertexShader,
                fragmentShader: ellipseFragmentShader,
                uniforms: {
                    uColor: { value: new THREE.Color(ELLIPSE_COLOR) },
                    uDiameter: { value: new THREE.Vector2(ELLIPSE_DIAMETER_X, ELLIPSE_DIAMETER_Y) },
                    uThickness: { value: ELLIPSE_THICKNESS },
                    uSoftness: { value: ELLIPSE_SOFTNESS },
                    uOffset: { value: new THREE.Vector2(ELLIPSE_OFFSET_X, ELLIPSE_OFFSET_Y) }
                },
                transparent: true,
                depthWrite: false
            });

            const ellipseGeometry = new THREE.PlaneGeometry(200, 200);
            ellipsePlane = new THREE.Mesh(ellipseGeometry, ellipseMaterial);
            ellipsePlane.position.y = 0.01; // Raised slightly higher
            ellipsePlane.rotation.x = -Math.PI / 2;
            scene.add(ellipsePlane);
        }

        // --- MODIFIED: Function to update the ellipse based on UI controls ---
        function updateEllipseEffect() {
            if (!ellipseMaterial) return;

            ellipseMaterial.uniforms.uColor.value.set(document.getElementById('ellipse-color-picker').value);
            ellipseMaterial.uniforms.uDiameter.value.x = parseFloat(document.getElementById('ellipse-diameter-x-slider').value);
            ellipseMaterial.uniforms.uDiameter.value.y = parseFloat(document.getElementById('ellipse-diameter-y-slider').value);
            ellipseMaterial.uniforms.uThickness.value = parseFloat(document.getElementById('ellipse-thickness-slider').value);
            ellipseMaterial.uniforms.uSoftness.value = parseFloat(document.getElementById('ellipse-softness-slider').value);
            ellipseMaterial.uniforms.uOffset.value.x = parseFloat(document.getElementById('ellipse-offset-x-slider').value);
            ellipseMaterial.uniforms.uOffset.value.y = parseFloat(document.getElementById('ellipse-offset-y-slider').value);

            document.getElementById('ellipse-diameter-x-value').textContent = ellipseMaterial.uniforms.uDiameter.value.x.toFixed(2);
            document.getElementById('ellipse-diameter-y-value').textContent = ellipseMaterial.uniforms.uDiameter.value.y.toFixed(2);
            document.getElementById('ellipse-thickness-value').textContent = ellipseMaterial.uniforms.uThickness.value.toFixed(2);
            document.getElementById('ellipse-softness-value').textContent = ellipseMaterial.uniforms.uSoftness.value.toFixed(2);
            document.getElementById('ellipse-offset-x-value').textContent = ellipseMaterial.uniforms.uOffset.value.x.toFixed(2);
            document.getElementById('ellipse-offset-y-value').textContent = ellipseMaterial.uniforms.uOffset.value.y.toFixed(2);
        }

        function createDefaultPlaceholderTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const context = canvas.getContext('2d');
            context.fillStyle = PLANE_FALLBACK_COLOR;
            context.fillRect(0, 0, 1, 1);
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Create a group to act as the camera's parent for hover animations
            cameraGroup = new THREE.Group();
            scene.add(cameraGroup);

            // --- Orthographic Camera ---
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1000, 1000);
            updateCameraFrustum();

            // Add the camera to the group instead of the scene
            cameraGroup.add(camera);

            camera.position.copy(INITIAL_CAMERA_POSITION);
            camera.zoom = INITIAL_CAMERA_ZOOM;
            camera.updateProjectionMatrix();

            // WebGL Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            maxAnisotropy = renderer.capabilities.getMaxAnisotropy();

            // CSS3D Renderer
            cssRenderer = new CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            css3dContainer.appendChild(cssRenderer.domElement);

            // Controls - still target the camera object directly
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enablePan = false;

            initialCameraState.position.copy(camera.position);
            initialCameraState.target.copy(controls.target);
            initialControlLimits = {
                minAzimuth: controls.minAzimuthAngle,
                maxAzimuth: controls.maxAzimuthAngle,
                minPolar: controls.minPolarAngle,
                maxPolar: controls.maxPolarAngle,
                minZoom: INITIAL_MIN_ZOOM,
                maxZoom: INITIAL_MAX_ZOOM
            };
            controls.minZoom = initialControlLimits.minZoom;
            controls.maxZoom = initialControlLimits.maxZoom;

            // Lighting
            const hemisphereLight = new THREE.HemisphereLight(HEMISPHERE_LIGHT_SKY_COLOR, HEMISPHERE_LIGHT_GROUND_COLOR, HEMISPHERE_LIGHT_INTENSITY);
            scene.add(hemisphereLight);

            const ambientLight = new THREE.AmbientLight(AMBIENT_LIGHT_COLOR, AMBIENT_LIGHT_INTENSITY);
            scene.add(ambientLight);

            new RGBELoader().load(HDRI_URL, function(texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                scene.environmentIntensity = HDRI_INTENSITY;
            });

            // --- Set initial values for grid controls and create the grid ---
            gridWidthSlider.value = GRID_WIDTH;
            gridHeightSlider.value = GRID_HEIGHT;
            squareSizeSlider.value = SQUARE_SIZE;
            gridThicknessSlider.value = GRID_THICKNESS;
            gridColorPicker.value = GRID_COLOR;
            gridOffsetXSlider.value = GRID_OFFSET_X;
            gridOffsetZSlider.value = GRID_OFFSET_Z;
            updateCustomGrid();

            // --- Set initial values for ellipse controls and create the effect ---
            document.getElementById('ellipse-color-picker').value = ELLIPSE_COLOR;
            document.getElementById('ellipse-diameter-x-slider').value = ELLIPSE_DIAMETER_X;
            document.getElementById('ellipse-diameter-y-slider').value = ELLIPSE_DIAMETER_Y;
            document.getElementById('ellipse-thickness-slider').value = ELLIPSE_THICKNESS;
            document.getElementById('ellipse-softness-slider').value = ELLIPSE_SOFTNESS;
            document.getElementById('ellipse-offset-x-slider').value = ELLIPSE_OFFSET_X;
            document.getElementById('ellipse-offset-y-slider').value = ELLIPSE_OFFSET_Y;
            createEllipseEffect();
            updateEllipseEffect(); // Call once to set initial text values

            // --- Create and position 3D text objects ---
            const leftTextElement = document.getElementById('left-text-container');
            leftTextObject = new CSS3DObject(leftTextElement); // MODIFIED: Use top-level variable
            leftTextObject.position.set(4.8, 0.01, -7.5)
            leftTextObject.rotation.x = -Math.PI / 2;
            leftTextObject.scale.set(0.007, 0.007, 0.007);
            scene.add(leftTextObject);

            const rightTextElement = document.getElementById('right-text-container');
            rightTextObject = new CSS3DObject(rightTextElement); // MODIFIED: Use top-level variable
            rightTextObject.position.set(-4.3, 0.01, 2);
            rightTextObject.rotation.x = -Math.PI / 2;
            rightTextObject.scale.set(0.007, 0.007, 0.007);
            scene.add(rightTextObject);

            const links = rightTextElement.querySelectorAll('a');
            links.forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault(); // Prevent the link from navigating away
                    const linkName = event.target.textContent; // Gets the text like "WORK", "CONTACT"
                    handleTextLinkClick(linkName);
                });
            });


            // --- Create Interactive CSS3DObject ---
            const iframeInteractive = document.createElement('iframe');
            iframeInteractive.src = INTERACTIVE_URL;
            iframeInteractive.style.width = `${PLANE_RESOLUTION.width}px`;
            iframeInteractive.style.height = `${PLANE_RESOLUTION.height}px`;
            iframeInteractive.style.overflow = 'hidden';
            iframeInteractive.style.opacity = '1';
            iframeInteractive.style.borderRadius = '0px';


            cssObject = new CSS3DObject(iframeInteractive);
            cssObject.scale.set(PLANE_SCALE, PLANE_SCALE, PLANE_SCALE);
            cssObject.position.copy(PLANE_POSITION);
            cssObject.rotation.set(
                THREE.MathUtils.degToRad(PLANE_ROTATION_DEGREES.x),
                THREE.MathUtils.degToRad(PLANE_ROTATION_DEGREES.y),
                THREE.MathUtils.degToRad(PLANE_ROTATION_DEGREES.z)
            );
            cssObject.visible = true;
            scene.add(cssObject);

            const strokeElement = document.getElementById('iframe-stroke');
            strokeObject = new CSS3DObject(strokeElement);

            strokeObject.position.copy(cssObject.position);
            strokeObject.rotation.copy(cssObject.rotation);
            strokeObject.scale.copy(cssObject.scale);

              // Position it slightly in front of the iframe to ensure it's on top
              strokeObject.position.z += 0.001; // A small offset is enough

              scene.add(strokeObject);


            // --- NEW: Create and Position the Blinking Layer RELATIVE to the main plane ---
            blinkingLayer = document.createElement('div');
            blinkingLayer.style.width = `${BLINKING_LAYER_WIDTH}px`;
            blinkingLayer.style.height = `${BLINKING_LAYER_HEIGHT}px`;
            blinkingLayer.style.backgroundColor = 'rgba(240, 240, 240, 1)';
            blinkingLayer.style.borderRadius = `${BLINKING_LAYER_CORNER_RADIUS}px`;
            blinkingLayer.style.boxShadow = `0 0 15px 5px ${BLINKING_LAYER_GLOW_COLOR}`;
            blinkingLayer.style.opacity = '0'; // Start invisible

            blinkingLayerObject = new CSS3DObject(blinkingLayer);
            blinkingLayerObject.scale.copy(cssObject.scale);
            blinkingLayerObject.rotation.copy(cssObject.rotation);
            // Calculate final position by adding the offset to the main plane's position
            const finalBlinkingLayerPosition = cssObject.position.clone().add(BLINKING_LAYER_POSITION_OFFSET);
            blinkingLayerObject.position.copy(finalBlinkingLayerPosition);
            blinkingLayerObject.visible = false; // Start hidden
            scene.add(blinkingLayerObject);


            // Set initial camera to focus on the CSS3D Object
            const initialTargetPosition = new THREE.Vector3();
            cssObject.getWorldPosition(initialTargetPosition);
            const initialCameraPos = initialTargetPosition.clone().add(BOOT_CAMERA_POSITION_OFFSET);

            camera.position.copy(initialCameraPos);
            controls.target.copy(initialTargetPosition);
            camera.zoom = BOOT_CAMERA_ZOOM;
            camera.updateProjectionMatrix();


            // --- Create Placeholder Plane ---
            const planeGeom = new THREE.PlaneGeometry(PLANE_RESOLUTION.width * PLANE_SCALE, PLANE_RESOLUTION.height * PLANE_SCALE);

            // Directly load your texture when creating the material
            const placeholderMaterial = new THREE.MeshBasicMaterial({
                // Replace the default texture with the texture loader
                map: new THREE.TextureLoader().load(
                    'baseScreenshot/base.png', // <-- Your local path or image URL here
                    (texture) => {
                        // Optional: This function runs on successful load
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.anisotropy = maxAnisotropy;
                    },
                    undefined, // Optional: onProgress callback
                    (error) => {
                        // Optional: This function runs if the image fails to load
                        console.error('Initial texture failed to load.');
                    }
                ),
                side: THREE.DoubleSide,
                color: 0xcdcdcd, // Keep as white to not tint your texture
                transparent: true,
                opacity: 1 // Set opacity to 1 to make it visible
            });

            // This is the line where it's actually created
            placeholderPlane = new THREE.Mesh(planeGeom, placeholderMaterial);

            // These lines configure its position and rotation
            placeholderPlane.position.copy(PLANE_POSITION);
            placeholderPlane.rotation.copy(cssObject.rotation);

            // Set the plane to be visible from the start
            placeholderPlane.visible = true;
            scene.add(placeholderPlane);


            // --- Create Texture Overlay Plane ---
            const overlayMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0, // Start fully transparent
                side: THREE.DoubleSide
            });
            textureOverlayPlane = new THREE.Mesh(planeGeom, overlayMaterial);
            textureOverlayPlane.position.copy(placeholderPlane.position);
            textureOverlayPlane.rotation.copy(placeholderPlane.rotation);
            textureOverlayPlane.translateZ(OVERLAY_PLANE_DISTANCE);
            textureOverlayPlane.scale.set(OVERLAY_PLANE_SCALE, OVERLAY_PLANE_SCALE, OVERLAY_PLANE_SCALE);
            scene.add(textureOverlayPlane);

            // Load the overlay texture
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(OVERLAY_TEXTURE_URL, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                textureOverlayPlane.material.map = texture;
                textureOverlayPlane.material.needsUpdate = true;
            }, undefined, (error) => {
                // console.error("Could not load the overlay texture:", error);
                showMessage('Could not load overlay texture.', 'error');
            });


            // --- MODIFIED: Event Listeners for Click vs. Drag with Long Press Indicator ---
            renderer.domElement.addEventListener('mousedown', (event) => {

              if(isTransitioning||isInBootState) return;

                isMouseDown = true;
                dragHappened = false;


                // Handle long press indicator logic
                if (isFocused) {

                     gsap.killTweensOf(longPressIndicator);
                    mouseDownTime = performance.now();

                    if (loadedModel) {
                        const intersects = raycaster.intersectObjects(loadedModel.children, true);
                        if (intersects.length > 0) {
                          mouseDownTime = 0;
                            return
                        }
                    }




                    const x = event.clientX;
                    const y = event.clientY;
                    iframe.contentWindow.postMessage('captureScreenshot', '*');
                    // Set indicator SVG properties from constants
                    const svg = longPressIndicator.querySelector('svg');
                    svg.setAttribute('width', INDICATOR_SIZE);
                    svg.setAttribute('height', INDICATOR_SIZE);
                    svg.setAttribute('viewBox', `0 0 ${INDICATOR_SIZE} ${INDICATOR_SIZE}`);
                    indicatorCircle.setAttribute('cx', INDICATOR_SIZE / 2);
                    indicatorCircle.setAttribute('cy', INDICATOR_SIZE / 2);
                    indicatorCircle.setAttribute('r', INDICATOR_SIZE / 2 - INDICATOR_INITIAL_STROKE);
                    indicatorCircle.setAttribute('stroke', INDICATOR_COLOR);
                    indicatorCircle.setAttribute('stroke-width', INDICATOR_INITIAL_STROKE);


                    // Reset and position the indicator at the cursor
                    gsap.set(longPressIndicator, {
                        left: x + INDICATOR_OFFSET.x,
                        top: y + INDICATOR_OFFSET.y,
                        scale: 1,
                        opacity: INDICATOR_INITIAL_OPACITY,
                        display: 'block'
                    });

                    // Prepare the SVG circle for the drawing animation
                    const circumference = 2 * Math.PI * indicatorCircle.r.baseVal.value;
                    gsap.set(indicatorCircle, {
                        strokeDasharray: circumference,
                        strokeDashoffset: circumference,
                    });

                    // Start the clockwise drawing animation
                    longPressTween = gsap.to(indicatorCircle, {
                        strokeDashoffset: 0,
                        duration: CLICK_THRESHOLD_MS / 1000,
                        ease: "none",
                        onComplete: () => {
                            // Threshold crossed: trigger the bouncy/fade-in animation
                            gsap.to(longPressIndicator, {
                                scale: 1.1,
                                opacity: 1,
                                duration: INDICATOR_BOUNCE_DURATION,
                                ease: INDICATOR_BOUNCE_EASE
                            });
                             // Animate the stroke width to make it thicker
                            gsap.to(indicatorCircle, {
                                attr: { "stroke-width": INDICATOR_COMPLETED_STROKE },
                                duration: INDICATOR_BOUNCE_DURATION,
                                ease: "power2.out"
                            });
                        }
                    });
                }
            }, false);

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    // Fade out text on first drag motion
                    if (!dragHappened && (leftTextObject && rightTextObject)) {
                        gsap.to([leftTextObject.element.style, rightTextObject.element.style], {
                            opacity: 0,
                            duration: 0.3,
                            ease: "power1.inOut"
                        });
                    }
                    dragHappened = true;

                    // Update indicator position while dragging
                    if (isFocused) {
                        gsap.to(longPressIndicator, {
                            left: event.clientX + INDICATOR_OFFSET.x,
                            top: event.clientY + INDICATOR_OFFSET.y,
                            duration: 0.1
                        });
                    }
                }
                 onMouseMove(event); // Keep this for raycasting
            }, false);

            renderer.domElement.addEventListener('mouseup', (event) => {
                // Handle release animation for the long press indicator


                if (isFocused) {
                    if (longPressTween) {
                        longPressTween.kill();
                    }

                    if(mouseDownTime==0)  return;
                    const clickDuration = performance.now() - mouseDownTime;

                    if (clickDuration < CLICK_THRESHOLD_MS) {
                        // ROLLBACK ANIMATION
                        const circumference = 2 * Math.PI * indicatorCircle.r.baseVal.value;
                        gsap.to(indicatorCircle, {
                            strokeDashoffset: circumference,
                            duration: INDICATOR_ROLLBACK_DURATION,
                            ease: "power1.inOut"
                        });
                        gsap.to(longPressIndicator, {
                            opacity: 0,
                            duration: INDICATOR_ROLLBACK_DURATION,
                            ease: "power1.inOut",
                            onComplete: () => {
                                longPressIndicator.style.display = 'none';
                            }
                        });

                    } else {
                        // SUCCESS ANIMATION
                        gsap.to(longPressIndicator, {
                            scale: INDICATOR_SUCCESS_SCALE,
                            opacity: 0,
                            duration: INDICATOR_SUCCESS_DURATION,
                            ease: "cubic-bezier(0.8,0,0.9,0.9)",
                            onComplete: () => {
                                longPressIndicator.style.display = 'none';
                                // Reset stroke width for the next time
                                gsap.set(indicatorCircle, { attr: { "stroke-width": INDICATOR_INITIAL_STROKE } });
                            }
                        });
                    }
                }

                if (isMouseDown) {
                    if (dragHappened && !isFocused && !isInBootState) {
                        // Handle snap-back after dragging
                        const onSnapBackComplete = () => {
                            if (leftTextObject && rightTextObject && !isMouseDown) {
                                gsap.to([leftTextObject.element.style, rightTextObject.element.style], {
                                    opacity: 1,
                                    duration: 0.5,
                                    ease: "power2.out"
                                });
                            }
                        };
                        const targetState = isFocused ? focusedCameraState : initialCameraState;
                        gsap.to(camera.position, {
                            ...targetState.position,
                            duration: SNAP_BACK_DURATION,
                            ease: SNAP_BACK_EASING,
                            onComplete: onSnapBackComplete
                        });
                        gsap.to(controls.target, {
                            ...targetState.target,
                            duration: SNAP_BACK_DURATION,
                            ease: SNAP_BACK_EASING
                        });
                    } else {
                        // This was a CLICK (not a drag)
                        const clickDuration = performance.now() - mouseDownTime;
                        if (clickDuration >= CLICK_THRESHOLD_MS) {
                            // Long press completed
                            handleSceneClick(event, true);
                            showMessage('Long press detected.', 'info');
                        } else {
                            // Short click
                            handleSceneClick(event, false);
                        }
                    }
                }
                isMouseDown = false;
                dragHappened = false;
            }, false);


            // --- Add event listeners for iframe mouse state ---
            const iframe = cssObject.element;
            iframe.addEventListener('mouseenter', () => { isMouseOverIframe = true; });
            iframe.addEventListener('mouseleave', () => { isMouseOverIframe = false; });



            window.addEventListener('message', (event) => {
              // ---- NEW: Handle keydown events from the iframe ----
              if (event.data && event.data.type === 'iframe_keydown') {


                  if (event.data.code === 'Space') {
                      if (spacebarSound) {
                          spacebarSound.currentTime = 0;
                          spacebarSound.play().catch(e => console.log("Spacebar sound blocked:", e));
                      }
                  } else if (keyboardKeys.length > 0) {
                      playRandomKeypressSound(); // This function already plays a random keypress sound
                  }
                  return; // End execution here for this message type
              }
              // ---- END of new code block ----


              // Your existing message handlers...
              if (event.data && event.data.type === 'screenshotData') {
                  const bitmap = event.data.bitmap;
                  // ... rest of your screenshot logic
                  // ...
                  return;
              } else if (event.data && event.data.type === 'focus') {
                  // ... your focus logic
              } else if (event.data && event.data.type === 'relax') {
                  // ... your relax logic
              } else if (event.data && event.data.type === 'bootfinished') {
                  // ... your bootfinished logic
              }
          });

            // --- REVISED: Proportional orbit based on mouse position ---
            window.addEventListener('mousemove', (event) => {
                if (!isFocused || isTransitioning || isMouseOverIframe) {
                    return;
                }

                const screenWidth = window.innerWidth;
                const mouseX = event.clientX; // Use event.clientX

                // Calculate the boundaries of the safe zone in pixels
                const safeZoneHalfWidth = (screenWidth * ORBIT_SAFE_ZONE_WIDTH) / 2;
                const safeZoneStart = screenWidth / 2 - safeZoneHalfWidth;
                const safeZoneEnd = screenWidth / 2 + safeZoneHalfWidth;

                // Calculate the boundaries of the full area of effect
                const effectAreaHalfWidth = (screenWidth * ORBIT_AREA_OF_EFFECT) / 2;
                const effectAreaStart = screenWidth / 2 - effectAreaHalfWidth;
                const effectAreaEnd = screenWidth / 2 + effectAreaHalfWidth;

                // The width of the zone on one side where the orbit effect is active
                const orbitZoneWidth = safeZoneStart - effectAreaStart;

                let orbitIntensity = 0; // -1 for full left, 1 for full right
                let inSafeZone = true; // Flag to track if we are in the safe zone

                if (mouseX < safeZoneStart) { // Cursor is to the left of the safe zone
                    inSafeZone = false;
                    // Calculate progress within the left orbit zone, clamping at the edge of the effect area
                    const clampedMouseX = Math.max(mouseX, effectAreaStart);
                    const rawIntensity = (safeZoneStart - clampedMouseX) / orbitZoneWidth;
                    const easedIntensity = gsap.parseEase("power1.out")(rawIntensity);
                    orbitIntensity = -easedIntensity;

                } else if (mouseX > safeZoneEnd) { // Cursor is to the right of the safe zone
                    inSafeZone = false;
                    // Calculate progress within the right orbit zone, clamping at the edge of the effect area
                    const clampedMouseX = Math.min(mouseX, effectAreaEnd);
                    const rawIntensity = (clampedMouseX - safeZoneEnd) / orbitZoneWidth;
                    const easedIntensity = gsap.parseEase("power1.out")(rawIntensity);
                    orbitIntensity = easedIntensity;
                }
                // If in safe zone, intensity remains 0.

                // Map the intensity to an angle offset.
                const angleOffset = orbitIntensity * THREE.MathUtils.degToRad(MAX_ORBIT_ANGLE);
                const targetAngle = focusInitialAzimuth + angleOffset;

                // Calculate the new camera position based on the angle and radius
                const targetX = controls.target.x + focusInitialRadius * Math.cos(targetAngle);
                const targetZ = controls.target.z + focusInitialRadius * Math.sin(targetAngle);

                // Kill any previous tween to avoid conflicts and animate smoothly.
                gsap.killTweensOf(camera.position);
                gsap.to(camera.position, {
                    x: targetX,
                    z: targetZ,
                    // Use a faster, snappier animation when returning to the center (safe zone)
                    duration: inSafeZone ? 0.5 : 1.0,
                    ease: inSafeZone ? 'power2.out' : 'power3.out'
                });

                // --- NEW: Animate text objects to orbit as well ---
                const textAngleOffset = targetAngle - focusInitialAzimuth;
                const rotationMatrix = new THREE.Matrix4().makeRotationY(textAngleOffset);

                const leftTextRelativePos = new THREE.Vector3().subVectors(leftTextInitialPos, controls.target);
                const rightTextRelativePos = new THREE.Vector3().subVectors(rightTextInitialPos, controls.target);

                leftTextRelativePos.applyMatrix4(rotationMatrix);
                rightTextRelativePos.applyMatrix4(rotationMatrix);

                const newLeftTextPos = new THREE.Vector3().addVectors(leftTextRelativePos, controls.target);
                const newRightTextPos = new THREE.Vector3().addVectors(rightTextRelativePos, controls.target);

                gsap.killTweensOf(leftTextObject.position);
                gsap.to(leftTextObject.position, {
                    x: newLeftTextPos.x,
                    z: newLeftTextPos.z,
                    duration: inSafeZone ? 0.5 : 1.0,
                    ease: inSafeZone ? 'power2.out' : 'power3.out'
                });

                gsap.killTweensOf(rightTextObject.position);
                gsap.to(rightTextObject.position, {
                    x: newRightTextPos.x,
                    z: newRightTextPos.z,
                    duration: inSafeZone ? 0.5 : 1.0,
                    ease: inSafeZone ? 'power2.out' : 'power3.out'
                });
            });

            // --- NEW: Add a mouseleave event to reset the orbit when the cursor leaves the window ---
            window.addEventListener('mouseleave', () => {
                if (!isFocused || isTransitioning) {
                    return;
                }

                // Calculate the reset position
                const targetX = controls.target.x + focusInitialRadius * Math.cos(focusInitialAzimuth);
                const targetZ = controls.target.z + focusInitialRadius * Math.sin(focusInitialAzimuth);

                // Animate back to the center
                gsap.killTweensOf(camera.position);
                gsap.to(camera.position, {
                    x: targetX,
                    z: targetZ,
                    duration: 0.5, // Faster reset
                    ease: 'power2.out'
                });

                // Animate text back to initial positions
                gsap.killTweensOf(leftTextObject.position);
                gsap.to(leftTextObject.position, {
                    x: leftTextInitialPos.x,
                    z: leftTextInitialPos.z,
                    duration: 0.5,
                    ease: 'power2.out'
                });
                gsap.killTweensOf(rightTextObject.position);
                gsap.to(rightTextObject.position, {
                    x: rightTextInitialPos.x,
                    z: rightTextInitialPos.z,
                    duration: 0.5,
                    ease: 'power2.out'
                });
            });


            if (DEFAULT_GLB_URL !== '') {
               // If a default URL is provided, load the model and hide the file input UI
               //console.log('this happened');
               loadGLBModel(DEFAULT_GLB_URL);
             }

            animate();
        }

        // --- NEW: Function to handle mouse movement for hover checks ---
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1) for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function updateCameraFrustum() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -FRUSTUM_HEIGHT * aspect / 2;
            camera.right = FRUSTUM_HEIGHT * aspect / 2;
            camera.top = FRUSTUM_HEIGHT / 2;
            camera.bottom = -FRUSTUM_HEIGHT / 2;
            camera.updateProjectionMatrix();
        }


        function handleTextLinkClick(linkName) {
      if (isTransitioning || isFocused) return; // Prevent action if already moving or focused

      // Define what to do once the animation is complete
      const onAnimationComplete = () => {
          const iframe = cssObject.element;
          const message = `open_${linkName.toLowerCase()}`;
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(message, '*');
          }
          // Re-enable interactions
          renderer.domElement.style.pointerEvents = 'auto';
      };

      // Disable interactions before the animation starts
      renderer.domElement.style.pointerEvents = 'none';

      // Call our newly flexible function with the max zoom level and the completion callback
      enterFocusMode(FOCUSED_MAX_ZOOM, onAnimationComplete);
  }

        function enterFocusMode(customZoom = null, onCompleteCallback = null) {
            if (isFocused || isInBootState) return;
            isFocused = true;
            isTransitioning = true;

            const animationDuration = customZoom !== null ? FOCUS_ANIMATION_DURATION * 1.5 : FOCUS_ANIMATION_DURATION;
            const targetZoom = customZoom !== null ? customZoom : FOCUSED_CAMERA_ZOOM;

            leftTextInitialPos.copy(leftTextObject.position);
            rightTextInitialPos.copy(rightTextObject.position);

            // Fade out the hover effect as we leave the initial state
            gsap.to(hoverIntensity, { value: 0, duration: HOVER_FADE_DURATION, ease: "power2.inOut" });

            cssObject.visible = true;

            controls.minAzimuthAngle = -Infinity;
            controls.maxAzimuthAngle = Infinity;
            controls.minPolarAngle = -Infinity;
            controls.maxPolarAngle = Infinity;
            controls.minZoom = -Infinity;
            controls.maxZoom = Infinity;
            controls.enabled = false;

            const targetPosition = new THREE.Vector3();
            cssObject.getWorldPosition(targetPosition);

            const newCameraPos = targetPosition.clone().add(FOCUSED_CAMERA_POSITION_OFFSET);

            // --- NEW: Store the initial angle and radius for the orbit effect ---
            focusInitialRadius = newCameraPos.distanceTo(targetPosition);
            focusInitialAzimuth = Math.atan2(newCameraPos.z - targetPosition.z, newCameraPos.x - targetPosition.x);


            focusedCameraState.position.copy(newCameraPos);
            focusedCameraState.target.copy(targetPosition);

             const iframe = cssObject.element;
               iframe.contentWindow.postMessage('enter', '*');
            const timeline = gsap.timeline({
                onComplete: () => {
                    controls.enableRotate = false; // MODIFIED: Disable manual rotation
                    controls.enableZoom = false; // Ensure zoom is still enabled
                    placeholderPlane.visible = false;

                    const degToRad = Math.PI / 180;
                    const currentAzimuth = controls.getAzimuthalAngle();
                    const currentPolar = controls.getPolarAngle();

                    controls.minAzimuthAngle = currentAzimuth - (FOCUSED_ORBIT_LIMIT_LEFT * degToRad);
                    controls.maxAzimuthAngle = currentAzimuth + (FOCUSED_ORBIT_LIMIT_RIGHT * degToRad);
                    controls.minPolarAngle = currentPolar - (FOCUSED_ORBIT_LIMIT_UP * degToRad);
                    controls.maxPolarAngle = currentPolar + (FOCUSED_ORBIT_LIMIT_DOWN * degToRad);
                    controls.minZoom = FOCUSED_MIN_ZOOM;
                    controls.maxZoom = FOCUSED_MAX_ZOOM;
                    controls.update();
                    isTransitioning = false;

                    if (onCompleteCallback) {
                          onCompleteCallback();
                      }
                }
            });

            timeline.to(camera.position, {
                x: newCameraPos.x,
                y: newCameraPos.y,
                z: newCameraPos.z,
                duration: animationDuration,
                ease: FOCUS_EASING
            }, 0)
            .to(controls.target, {
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                duration: animationDuration,
                ease: FOCUS_EASING
            }, 0)
            .to(camera, {
                zoom: targetZoom,
                duration: animationDuration,
                ease: FOCUS_EASING,
                onUpdate: () => camera.updateProjectionMatrix()
            }, 0)
            .to([leftTextObject.element.style, rightTextObject.element.style], {
                opacity: 0,
                duration: 0.3, // A quick fade-out
                ease: "power1.out"
            }, 0);

            const crossfadeStartTime = animationDuration - CROSSFADE_DURATION;
            timeline.to(textureOverlayPlane.material, {
                opacity: 0,
                duration: CROSSFADE_DURATION,
                ease: "none"
            }, crossfadeStartTime)
            .to(placeholderPlane.material, {
                opacity: 0,
                duration: CROSSFADE_DURATION,
                ease: "none"
            }, crossfadeStartTime)
            .to(cssObject.element.style, {
                opacity: 1,
                duration: CROSSFADE_DURATION,
                ease: "none"
            }, crossfadeStartTime)
            .to(iframe.style, { // Target iframe's style
                opacity: 1, // Fades in the iframe
                duration: CROSSFADE_DURATION,
                ease: "none",
                onStart: () => {
                    // Set pointer-events to auto when fade-in starts
                    iframe.style.pointerEvents = 'auto';
                }
            }, animationDuration);
        }

        function exitFocusMode() {
            if (!isFocused || isInBootState) return;
            isFocused = false;
            isTransitioning = true;

            const iframe = cssObject.element;
              iframe.contentWindow.postMessage('exit', '*');
            if (iframe && iframe.contentWindow) {
                //
                // console.log("Requested screenshot from iframe.");
            } else {
                // console.error("Cannot access iframe contentWindow to request screenshot.");
                createFallbackPlaceholder();
            }

            controls.minAzimuthAngle = -Infinity;
            controls.maxAzimuthAngle = Infinity;
            controls.minPolarAngle = -Infinity;
            controls.maxPolarAngle = Infinity;
            controls.minZoom = -Infinity;
            controls.maxZoom = Infinity;

            const timeline = gsap.timeline({
                onComplete: () => {
                    controls.minAzimuthAngle = initialControlLimits.minAzimuth;
                    controls.maxAzimuthAngle = initialControlLimits.maxAzimuth;
                    controls.minPolarAngle = initialControlLimits.minPolar;
                    controls.maxPolarAngle = initialControlLimits.maxPolar;
                    controls.minZoom = initialControlLimits.minZoom;
                    controls.maxZoom = initialControlLimits.maxZoom;
                    controls.enableRotate = true; // MODIFIED: Re-enable manual rotation
                    controls.enableZoom = true;
                    cssObject.visible = false;
                     controls.enabled = true;
                    isTransitioning = false;
                }
            });

            // Synchronize the hover fade-in with the main camera animation
            timeline.to(hoverIntensity, {
                value: 1,
                duration: HOVER_FADE_DURATION,
                ease: "power2.inOut"
            }, 0);

            timeline.set(placeholderPlane, { visible: true }, 0);
            timeline.set(iframe.style, { pointerEvents: 'none' }, 0);

            timeline.to(cssObject.element.style, {
                opacity: 0,
                duration: CROSSFADE_DURATION,
                ease: "none"
            }, 0)
            .to(textureOverlayPlane.material, {
                opacity: 1,
                duration: CROSSFADE_DURATION,
                ease: "none"
            }, 0)
            .to(placeholderPlane.material, {
                opacity: 1,
                duration: CROSSFADE_DURATION,
                ease: "none"
            }, 0);

            timeline.to(camera.position, {
                x: initialCameraState.position.x,
                y: initialCameraState.position.y,
                z: initialCameraState.position.z,
                duration: FOCUS_ANIMATION_DURATION,
                ease: FOCUS_EASING
            }, 0)
            .to(controls.target, {
                x: initialCameraState.target.x,
                y: initialCameraState.target.y,
                z: initialCameraState.target.z,
                duration: FOCUS_ANIMATION_DURATION,
                ease: FOCUS_EASING
            }, 0)
            .to(camera, {
                zoom: INITIAL_CAMERA_ZOOM,
                duration: FOCUS_ANIMATION_DURATION,
                ease: FOCUS_EASING,
                onUpdate: () => camera.updateProjectionMatrix()
            }, 0)
            .to(leftTextObject.position, {
                x: leftTextInitialPos.x,
                y: leftTextInitialPos.y,
                z: leftTextInitialPos.z,
                duration: FOCUS_ANIMATION_DURATION,
                ease: FOCUS_EASING
            }, 0)
            .to(rightTextObject.position, {
                x: rightTextInitialPos.x,
                y: rightTextInitialPos.y,
                z: rightTextInitialPos.z,
                duration: FOCUS_ANIMATION_DURATION,
                ease: FOCUS_EASING
            }, 0)
            .to([leftTextObject.element.style, rightTextObject.element.style], {
                opacity: 1,
                duration: 0.3,
                ease: "power1.in"
            }, FOCUS_ANIMATION_DURATION);
        }

        function animateFromBootToInitial() {
            isInBootState = false;
            isTransitioning = true;
            controls.minAzimuthAngle = -Infinity;
            controls.maxAzimuthAngle = Infinity;
            controls.minPolarAngle = -Infinity;
            controls.maxPolarAngle = Infinity;
            controls.minZoom = -Infinity;
            controls.maxZoom = Infinity;

            const iframe = cssObject.element;

            const timeline = gsap.timeline({
                onComplete: () => {
                    controls.minAzimuthAngle = initialControlLimits.minAzimuth;
                    controls.maxAzimuthAngle = initialControlLimits.maxAzimuth;
                    controls.minPolarAngle = initialControlLimits.minPolar;
                    controls.maxPolarAngle = initialControlLimits.maxPolar;
                    controls.minZoom = initialControlLimits.minZoom;
                    controls.maxZoom = initialControlLimits.maxZoom;
                    controls.enabled = true;
                    cssObject.visible = false;
                    // Hide the blinking layer completely after fade
                    if (blinkingLayerObject) {
                        blinkingLayerObject.visible = false;
                    }
                    isTransitioning = false;
                }
            });

            // Synchronize the hover fade-in with the main camera animation
            timeline.to(hoverIntensity, {
                value: 1,
                duration: HOVER_FADE_DURATION,
                ease: "power2.inOut"
            }, 0);

            // --- UPDATED: Fade out the blinking layer using the global variable ---
            if (blinkingLayerObject) {
                timeline.to(blinkingLayerObject.element.style, {
                    opacity: 0,
                    duration: BLINKING_LAYER_FADE_OUT_DURATION,
                    ease: "power2.out"
                }, 0); // Start at the beginning of the timeline
            }


            timeline.set(placeholderPlane, { visible: true }, 0);

            timeline.to(camera.position, {
                x: initialCameraState.position.x,
                y: initialCameraState.position.y,
                z: initialCameraState.position.z,
                duration: BOOT_ANIMATION_DURATION,
                ease: BOOT_ANIMATION_EASING
            }, 0)
            .to(controls.target, {
                x: initialCameraState.target.x,
                y: initialCameraState.target.y,
                z: initialCameraState.target.z,
                duration: BOOT_ANIMATION_DURATION,
                ease: BOOT_ANIMATION_EASING
            }, 0)
            .to(camera, {
                zoom: INITIAL_CAMERA_ZOOM,
                duration: BOOT_ANIMATION_DURATION,
                ease: BOOT_ANIMATION_EASING,
                onUpdate: () => camera.updateProjectionMatrix()
            }, 0)
            .to(cssObject.element.style, {
                opacity: 0,
                duration: BOOT_CROSSFADE_DURATION,
                ease: "none"
            }, 0)
            .to(textureOverlayPlane.material, {
                opacity: 1,
                duration: BOOT_CROSSFADE_DURATION,
                ease: "none"
            }, 0)
            .to(placeholderPlane.material, {
                opacity: 1,
                duration: BOOT_CROSSFADE_DURATION,
                ease: "none"
            }, 0)
            .to(iframe.style, {
              opacity: 0,
              duration: BOOT_CROSSFADE_DURATION,
              ease: "none"
           }, 0);

        }

        function createFallbackPlaceholder() {
            const canvas = document.createElement('canvas');
            const textureResolution = 512;
            canvas.width = textureResolution;
            canvas.height = textureResolution * (PLANE_RESOLUTION.height / PLANE_RESOLUTION.width);

            const ctx = canvas.getContext('2d');
            ctx.fillStyle = PLANE_FALLBACK_COLOR;

            const radius = (PLANE_CORNER_RADIUS_PX / PLANE_RESOLUTION.width) * textureResolution;

            ctx.beginPath();
            ctx.roundRect(0, 0, canvas.width, canvas.height, radius);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;

            if (placeholderPlane.material.map) {
                placeholderPlane.material.map.dispose();
            }
            placeholderPlane.material.map = texture;
            placeholderPlane.material.needsUpdate = true;
        }

        window.addEventListener('message', (event) => {
          if (event.data && event.data.type === 'screenshotData') {
                 const bitmap = event.data.bitmap;

                 // Dispose of the old texture to free up GPU memory
                 const oldTexture = placeholderPlane.material.map;
                 if (oldTexture) {
                     oldTexture.dispose();
                 }

                 // Create a texture directly from the bitmap
                 const newTexture = new THREE.CanvasTexture(bitmap);
                 newTexture.colorSpace = THREE.SRGBColorSpace;
                 newTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                 newTexture.generateMipmaps = true;
                 newTexture.minFilter = THREE.LinearMipmapLinearFilter;

                 // **** THE CRUCIAL FIX IS HERE ****
                 // This disables the default vertical flip, fixing the issue.
                 //newTexture.flipY = false;

                 // Set the onUpdate callback to close the bitmap AFTER it's been used
                 newTexture.onUpdate = function() {
                     bitmap.close();
                     this.onUpdate = null;
                 };

                 // Apply the new texture
                 placeholderPlane.material.map = newTexture;
                 placeholderPlane.material.needsUpdate = true;

                 //console.log('Applied new texture with flipY=false.');
                 return;
             } else if (event.data && event.data.type === 'focus') { // New 'focus' message handler

              renderer.domElement.style.pointerEvents = 'none';

                if (isFocused) {
                    gsap.killTweensOf(camera); // Stop any existing camera animations
                    gsap.to(camera, {
                        zoom: FOCUSED_MAX_ZOOM,
                        duration: FOCUS_ANIMATION_DURATION*1, // Make it a bit faster
                        ease: FOCUS_EASING,
                        onUpdate: () => camera.updateProjectionMatrix(),
                        onComplete: () => {
                            // Re-enable clicks and restore the cursor
                        renderer.domElement.style.pointerEvents = 'auto';

                    }
                    });
                    showMessage('Camera zoomed in to max for focused view.', 'success');
                }
            } else if (event.data && event.data.type === 'relax') { // New 'relax' message handler

                renderer.domElement.style.pointerEvents = 'none';
                if (isFocused) {
                    gsap.killTweensOf(camera); // Stop any existing camera animations
                    gsap.to(camera, {
                        zoom: FOCUSED_MIN_ZOOM,
                        duration: FOCUS_ANIMATION_DURATION*1.8, // Make it a bit faster
                        ease: FOCUS_EASING,
                        onUpdate: () => camera.updateProjectionMatrix(),
                        onComplete: () => {
                            // Re-enable clicks and restore the cursor
                        renderer.domElement.style.pointerEvents = 'auto';
                      }
                    });
                    showMessage('Camera zoomed out to min for focused view.', 'success');
                }
            } else if (event.data && event.data.type === 'bootfinished'){
               boot_sequence_finished = true;

                gsap.to(strokeObject.element.style, { opacity: 0, duration: 0.5, onComplete: () => { strokeObject.visible = false; } });

               if(loadedModel){
                   const iframe = cssObject.element;
                   iframe.contentWindow.postMessage('boot_complete', '*');
                     startBootAnimationSequence();
               }
            }
        });

        // --- UPDATED: handleSceneClick with new blink animation ---
        function handleSceneClick(event, focusallowed = false) {
          if (isTransitioning) return;
            if (isInBootState) return;




            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const objectsToTest = scene.children.filter(obj => obj !== textureOverlayPlane);
            const intersects = raycaster.intersectObjects(objectsToTest, true);


             let clickedOnInteractiveObject = false;

            if (intersects.length > 0) {
                const firstIntersected = intersects[0].object;

                // --- Check if the clicked object is PART of the 86body group ---
                let is86BodyPart = false;
                if (body86) {
                    let currentObject = firstIntersected;
                    while (currentObject.parent) {
                        if (currentObject.parent === body86) {
                            is86BodyPart = true;
                            break;
                        }
                        currentObject = currentObject.parent;
                    }
                }

                if (is86BodyPart && !gsap.isTweening(body86.position)) {
                    // Animate the button press on the GROUP
                    gsap.timeline()
                        .to(body86.position, { y: body86InitialY - BODY86_PRESS_DEPTH, duration: 0.1 })
                        .to(body86.position, { y: body86InitialY, duration: 0.5, ease: `elastic.out(1, ${BODY86_BOUNCE_ELASTICITY})` });

                    // Animate the light blink: Flash ON, then fade OFF
                    if (lights86Material && !gsap.isTweening(lights86Material.color)) {
                        const blinkTimeline = gsap.timeline({
                            repeat: BODY86_LIGHT_BLINK_COUNT -1 // Repeat N-1 times for a total of N blinks
                        });

                        // Instantly flash ON
                        blinkTimeline.set(lights86Material, {
                            emissiveIntensity: BODY86_LIGHT_MAX_INTENSITY,
                            color: new THREE.Color(BODY86_LIGHT_EMISSIVE_COLOR)
                        })
                        // Then fade back to the OFF state
                        .to(lights86Material, {
                            emissiveIntensity: 0.1,
                            duration: BODY86_LIGHT_BLINK_DURATION,
                            ease: "power2.out"
                        })
                        .to(lights86Material.color, {
                            r: new THREE.Color(BODY86_LIGHT_BASE_COLOR).r,
                            g: new THREE.Color(BODY86_LIGHT_BASE_COLOR).g,
                            b: new THREE.Color(BODY86_LIGHT_BASE_COLOR).b,
                            duration: BODY86_LIGHT_BLINK_DURATION,
                            ease: "power2.out"
                        }, "<"); // The '<' makes this animation run in parallel with the one above
                    }

                    // --- NEW: Animate the ground lights ---
                    if (groundLightLeft && groundLightRight) {
                        const groundLightTimeline = gsap.timeline({
                            repeat: BODY86_LIGHT_BLINK_COUNT - 1
                        });
                        groundLightTimeline.set([groundLightLeft.material.uniforms.uOpacity, groundLightRight.material.uniforms.uOpacity], {
                            value: BODY86_GROUND_LIGHT_MAX_OPACITY
                        })
                        .to([groundLightLeft.material.uniforms.uOpacity, groundLightRight.material.uniforms.uOpacity], {
                            value: 0,
                            duration: BODY86_LIGHT_BLINK_DURATION,
                            ease: "power2.out"
                        });
                    }

                    return; // Stop further processing
                }


                let isWobbleHeadPart = false;
                if (lottieHeadPivot) {
                    let currentObject = firstIntersected;
                    while (currentObject.parent) {
                        if (currentObject.parent === lottieHeadPivot) {
                            isWobbleHeadPart = true;
                            break;
                        }
                        currentObject = currentObject.parent;
                    }
                }

                if (isWobbleHeadPart) {
                    wobbleHead();
                    return;
                }

                if (firstIntersected === placeholderPlane && placeholderPlane.visible) {
                    enterFocusMode();
                    return;
                }

                if (loadedModel) {
                     let currentObject = firstIntersected;
                     // Traverse up the hierarchy to see if the clicked object is a descendant of loadedModel
                     while (currentObject) {
                         if (currentObject === loadedModel || (currentObject.parent && currentObject.parent === loadedModel)) {
                             clickedOnInteractiveObject = true;
                             break;
                         }
                         currentObject = currentObject.parent;
                         if (!currentObject) break;
                     }
                }

            }

            if (isFocused&&!clickedOnInteractiveObject&&focusallowed) {
              setTimeout(() => {
                exitFocusMode();
              }, 350);
            }
        }

        function wobbleHead() {
            if (!lottieHeadPivot || gsap.isTweening(lottieHeadPivot.rotation)) return;

            lottieHeadPivot.rotation.x = 0;
            lottieHeadPivot.rotation.z = 0;

            const wobbleAxis = Math.random() > 0.5 ? 'x' : 'z';
            const direction = Math.random() > 0.5 ? 1 : -1;

            const tl = gsap.timeline();
            tl.to(lottieHeadPivot.rotation, { [wobbleAxis]: direction * WOBBLE_STRENGTH, duration: WOBBLE_DURATION * 0.2, ease: "power1.out" })
              .to(lottieHeadPivot.rotation, { [wobbleAxis]: -direction * WOBBLE_STRENGTH * 0.6, duration: WOBBLE_DURATION * 0.2, ease: "power1.inOut" })
              .to(lottieHeadPivot.rotation, { [wobbleAxis]: direction * WOBBLE_STRENGTH * 0.3, duration: WOBBLE_DURATION * 0.2, ease: "power1.inOut" })
              .to(lottieHeadPivot.rotation, { [wobbleAxis]: -direction * WOBBLE_STRENGTH * 0.15, duration: WOBBLE_DURATION * 0.2, ease: "power1.inOut" })
              .to(lottieHeadPivot.rotation, { [wobbleAxis]: 0, duration: WOBBLE_DURATION * 0.2, ease: "power1.in" });
        }

        let messageTimeout;
        function showMessage(message, type = 'success') {
          /*
            messageText.textContent = message;

            messageBox.className = 'absolute top-5 left-1/2 -translate-x-1/2 p-4 rounded-lg text-white font-semibold shadow-2xl z-[70] pointer-events-none opacity-0 -translate-y-20';

            if (type === 'success') {
                messageBox.classList.add('bg-green-500');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-500');
            } else if (type === 'warning') {
                 messageBox.classList.add('bg-yellow-500');
            }

            messageBox.classList.remove('hidden');

            gsap.to(messageBox, { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" });

            if (messageTimeout) {
                clearTimeout(messageTimeout);
            }

            messageTimeout = setTimeout(() => {
                gsap.to(messageBox, { opacity: 0, y: -20, duration: 0.5, ease: "power2.in", onComplete: () => {
                    messageBox.classList.add('hidden');
                }});
            }, 4000);
            */
        }

        function createSmokeEffect(parentObject) {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float uTime;
                uniform float uTimeFrequency;
                uniform vec2 uUvFrequency;
                uniform vec3 uColor;
                uniform float uLength;
                uniform float uOpacity;
                uniform float uGlobalOpacity;

                varying vec2 vUv;

                vec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }
                vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }

                float perlin2d(vec2 P) {
                  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
                  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
                  Pi = mod(Pi, 289.0);
                  vec4 ix = Pi.xzxz;
                  vec4 iy = Pi.yyww;
                  vec4 fx = Pf.xzxz;
                  vec4 fy = Pf.yyww;
                  vec4 i = permute(permute(ix) + iy);
                  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;
                  vec4 gy = abs(gx) - 0.5;
                  vec4 tx = floor(gx + 0.5);
                  gx = gx - tx;
                  vec2 g00 = vec2(gx.x, gy.x);
                  vec2 g10 = vec2(gx.y, gy.y);
                  vec2 g01 = vec2(gx.z, gy.z);
                  vec2 g11 = vec2(gx.w, gy.w);
                  vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
                  g00 *= norm.x;
                  g01 *= norm.y;
                  g10 *= norm.z;
                  g11 *= norm.w;
                  float n00 = dot(g00, vec2(fx.x, fy.x));
                  float n10 = dot(g10, vec2(fx.y, fy.y));
                  float n01 = dot(g01, vec2(fx.z, fy.z));
                  float n11 = dot(g11, vec2(fx.w, fy.w));
                  vec2 fade_xy = fade(Pf.xy);
                  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
                  return 2.3 * n_xy;
                }

                void main() {
                  vec2 uv = vUv * uUvFrequency;
                  uv.y -= uTime * uTimeFrequency;

                  float borderAlpha = smoothstep(0.0, 0.25, vUv.x) * smoothstep(1.0, 0.75, vUv.x);
                  borderAlpha *= smoothstep(uLength, 0.0, vUv.y);
                  borderAlpha *= smoothstep(0.0, 0.1, vUv.y);

                  float perlin = perlin2d(uv);
                  perlin *= borderAlpha;
                  perlin *= 0.7;
                  perlin = min(perlin, 1.0);

                  gl_FragColor = vec4(uColor, perlin * uOpacity * uGlobalOpacity);
                }
            `;

            const createSmokeMaterial = (timeFrequency) => {
                return new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide,
                    uniforms: {
                        uTime: { value: 0 },
                        uTimeFrequency: { value: timeFrequency },
                        uUvFrequency: { value: new THREE.Vector2(SMOKE_UV_FREQUENCY_X, SMOKE_UV_FREQUENCY_Y) },
                        uColor: { value: new THREE.Color(SMOKE_COLOR) },
                        uLength: { value: SMOKE_LENGTH },
                        uOpacity: { value: 1.0 },
                        uGlobalOpacity: { value: SMOKE_GROUP_OPACITY }
                    }
                });
            };

            smokeMaterials = [createSmokeMaterial(SMOKE_TIME_FREQUENCY), createSmokeMaterial(SMOKE_TIME_FREQUENCY-0.1)];

            smokeGroup = new THREE.Group();
            const smokeGeometry = new THREE.PlaneGeometry(0.2, 1, 1, 10);

            const planes = [
                new THREE.Mesh(smokeGeometry, smokeMaterials[0]),
                new THREE.Mesh(smokeGeometry, smokeMaterials[1])
            ];

            planes[0].rotation.y = -Math.PI / 4;
            planes[1].rotation.y = Math.PI / 4;

            smokeGroup.add(planes[0], planes[1]);

            const box = new THREE.Box3().setFromObject(parentObject);
            const center = box.getCenter(new THREE.Vector3());
            const steamOrigin = new THREE.Vector3(center.x, box.max.y, center.z);
            parentObject.worldToLocal(steamOrigin);
            smokeGroup.position.copy(steamOrigin).add(SMOKE_GROUP_POSITION_OFFSET);
            smokeGroup.scale.set(SMOKE_GROUP_SCALE, SMOKE_GROUP_SCALE, SMOKE_GROUP_SCALE);
            smokeGroup.rotation.set(
                THREE.MathUtils.degToRad(SMOKE_GROUP_ROTATION_DEGREES.x),
                THREE.MathUtils.degToRad(SMOKE_GROUP_ROTATION_DEGREES.y),
                THREE.MathUtils.degToRad(SMOKE_GROUP_ROTATION_DEGREES.z)
            );

            parentObject.add(smokeGroup);
        }

        function createCoffeePlane(parentObject) {
            const coffeeGeometry = new THREE.CircleGeometry(COFFEE_PLANE_SCALE, 32);
            const coffeeMaterial = new THREE.MeshStandardMaterial({
                color: COFFEE_PLANE_COLOR,
                metalness: 0.8,
                roughness: 0.1,
                side: THREE.DoubleSide
            });
            const coffeePlane = new THREE.Mesh(coffeeGeometry, coffeeMaterial);

            const box = new THREE.Box3().setFromObject(parentObject);
            const center = box.getCenter(new THREE.Vector3());
            const coffeeOrigin = new THREE.Vector3(center.x, box.max.y, center.z);

            parentObject.worldToLocal(coffeeOrigin);
            coffeePlane.position.copy(coffeeOrigin).add(COFFEE_PLANE_POSITION_OFFSET);
            coffeePlane.rotation.x = -Math.PI / 2;

            parentObject.add(coffeePlane);

            const coffeeLight = new THREE.PointLight(COFFEE_LIGHT_COLOR, COFFEE_LIGHT_INTENSITY, COFFEE_LIGHT_DISTANCE);
            coffeeLight.position.copy(coffeePlane.position).add(COFFEE_LIGHT_POSITION_OFFSET);
            parentObject.add(coffeeLight);
        }

        // --- Function to load the bee model ---
        function loadBeeModel(originPosition) {
            const loader = new GLTFLoader();

            loader.load(BEE_URL, (gltf) => {
                if (beeModel) {
                    scene.remove(beeModel);
                }
                beeModel = gltf.scene;

                const basePosition = originPosition.clone().add(BEE_POSITION);
                beeModel.position.copy(basePosition);
                beeTargetPosition.copy(basePosition);

                beeModel.rotation.set(
                    THREE.MathUtils.degToRad(BEE_ROTATION.x),
                    THREE.MathUtils.degToRad(BEE_ROTATION.y),
                    THREE.MathUtils.degToRad(BEE_ROTATION.z)
                );
                beeModel.scale.copy(BEE_SCALE);

                beeInitialPosition.copy(basePosition);
                previousBeePosition.copy(basePosition);
                beeIdleStartTime = clock.getElapsedTime();

                // Set up animation
                if (gltf.animations && gltf.animations.length) {
                    beeMixer = new THREE.AnimationMixer(beeModel);

                    gltf.animations.forEach((clip) => {
                        const action = beeMixer.clipAction(clip);
                        action.timeScale = BEE_ANIMATION_SPEED;
                        action.play();
                    });

                    showMessage(`Bee animation started (${gltf.animations.length} clips).`, 'success');
                } else {
                    showMessage('Bee model loaded, but no animations were found.', 'warning');
                }

                scene.add(beeModel);
                //showMessage('Bee model loaded successfully!', 'success');

                // Start the bee's behavior loop
                startNewBeeMovement();

            }, undefined, (error) => {
                // console.error('An error happened while loading the bee model:', error);
                showMessage('Error loading the bee model. Check console.', 'error');
            });
        }

        // --- UPDATED: Function to start a new movement cycle for the bee with speed control ---
        function startNewBeeMovement(speedMultiplier = 1) {
            if (!beeModel) return;
            beeState = 'MOVING';

            // Generate a new random target within the defined radius from the initial position
            const newTargetX = beeInitialPosition.x + (Math.random() - 0.5) * 2 * BEE_MOVEMENT_RADIUS.x;
            const newTargetY = beeInitialPosition.y + (Math.random() - 0.5) * 2 * BEE_MOVEMENT_RADIUS.y;
            const newTargetZ = beeInitialPosition.z + (Math.random() - 0.5) * 2 * BEE_MOVEMENT_RADIUS.z;

            const newTargetPosition = new THREE.Vector3(newTargetX, newTargetY, newTargetZ);

            const moveDuration = THREE.MathUtils.lerp(BEE_MOVE_DURATION.min, BEE_MOVE_DURATION.max, Math.random());

            // Use GSAP to animate the bee to the new target position
            gsap.to(beeModel.position, {
                x: newTargetX,
                y: newTargetY,
                z: newTargetZ,
                duration: moveDuration / speedMultiplier, // Divide duration by the multiplier
                ease: "power2.inOut",
                onComplete: () => {
                    beeState = 'IDLE';
                    beeTargetPosition.copy(newTargetPosition);
                    beeIdleStartTime = clock.getElapsedTime(); // Fix stutter by resetting idle time
                    beeStateTimer = THREE.MathUtils.lerp(BEE_IDLE_DURATION.min, BEE_IDLE_DURATION.max, Math.random());
                }
            });
        }

        // --- Function to handle the bee's state machine ---
        function updateBeeBehavior(delta, elapsedTime) {
            if (!beeModel) return;

            // --- Rotation Logic (applies in both states for smoothness) ---
            const velocity = new THREE.Vector3().subVectors(beeModel.position, previousBeePosition);
            if (velocity.lengthSq() > 0.00001) {
                const targetQuaternion = new THREE.Quaternion();
                const lookAtPosition = new THREE.Vector3().addVectors(beeModel.position, velocity);
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.lookAt(beeModel.position, lookAtPosition, beeModel.up);
                targetQuaternion.setFromRotationMatrix(tempMatrix);

                const horizontalVelocity = new THREE.Vector3(velocity.x, 0, velocity.z);
                const bankAngle = -horizontalVelocity.length() * BEE_TILT_STRENGTH;
                const bankQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), bankAngle);

                targetQuaternion.multiply(bankQuaternion);

                // Use rotateTowards for a capped turn speed
                beeModel.quaternion.rotateTowards(targetQuaternion, BEE_MAX_YAW_RADIANS_PER_SEC * delta);
            }
            previousBeePosition.copy(beeModel.position);


            // --- State-specific Logic ---
            if (beeState === 'IDLE') {
                // Apply a small, local hover animation around the target position
                const timeInState = elapsedTime - beeIdleStartTime;
                const hoverOffsetX = Math.sin(timeInState * 4) * 0.02;
                const hoverOffsetY = Math.sin(timeInState * 5) * 0.03;
                const hoverOffsetZ = Math.sin(timeInState * 3) * 0.02;
                beeModel.position.x = beeTargetPosition.x + hoverOffsetX;
                beeModel.position.y = beeTargetPosition.y + hoverOffsetY;
                beeModel.position.z = beeTargetPosition.z + hoverOffsetZ;

                // Countdown the idle timer
                beeStateTimer -= delta;
                if (beeStateTimer <= 0) {
                    startNewBeeMovement(); // Autonomous movement uses default speed (1x)
                }
            }
        }

        // --- NEW: Function to create the ground light material ---
        function createGroundLightMaterial() {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform vec3 uColor;
                uniform float uOpacity;
                varying vec2 vUv;

                void main() {
                    vec2 centeredUv = vUv - 0.5;
                    float dist = length(centeredUv);

                    // Create a gradient for the angled light effect
                    float angleGradient = smoothstep(0.5, -0.2, vUv.y);

                    // Create the soft ellipse shape
                    float alpha = smoothstep(0.5, 0.0, dist);

                    gl_FragColor = vec4(uColor, alpha * uOpacity * angleGradient);
                }
            `;

            return new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                transparent: true,
                depthWrite: false,
                uniforms: {
                    uColor: { value: new THREE.Color(BODY86_GROUND_LIGHT_COLOR) },
                    uOpacity: { value: 0.0 } // Start invisible
                }
            });
        }

        // --- NEW: Function to create the ground lights ---
        function createGroundLights(originObject) {
            const groundLightGeometry = new THREE.PlaneGeometry(1, 1);

            // Create left light
            const leftMaterial = createGroundLightMaterial();
            groundLightLeft = new THREE.Mesh(groundLightGeometry, leftMaterial);

            const leftPosition = originObject.position.clone().add(BODY86_GROUND_LIGHT_OFFSET_LEFT);
            groundLightLeft.position.set(leftPosition.x, 0.01, leftPosition.z); // Place slightly above ground
            groundLightLeft.rotation.x = -Math.PI / 2; // Lay flat on the ground
            groundLightLeft.rotation.z = BODY86_GROUND_LIGHT_ROTATION;
            groundLightLeft.scale.copy(BODY86_GROUND_LIGHT_SCALE);
            scene.add(groundLightLeft);

            // Create right light
            const rightMaterial = createGroundLightMaterial();
            groundLightRight = new THREE.Mesh(groundLightGeometry, rightMaterial);

            const rightPosition = originObject.position.clone().add(BODY86_GROUND_LIGHT_OFFSET_RIGHT);
            groundLightRight.position.set(rightPosition.x, 0.01, rightPosition.z);
            groundLightRight.rotation.x = -Math.PI / 2;
            groundLightRight.rotation.z = BODY86_GROUND_LIGHT_ROTATION;
            groundLightRight.scale.copy(BODY86_GROUND_LIGHT_SCALE);
            scene.add(groundLightRight);
        }


        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // Animate the camera's parent group for a subtle hover effect
            if (cameraGroup) {
                cameraGroup.position.x = Math.cos(elapsedTime * HOVER_SPEED) * HOVER_AMPLITUDE * hoverIntensity.value;
                cameraGroup.position.y = Math.sin(elapsedTime * HOVER_SPEED) * HOVER_AMPLITUDE * hoverIntensity.value;
            }

            // --- UPDATED: Bee hover interaction logic ---
            if (beeModel) {
                // Update the raycaster with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);

                // Check for intersections with the bee model
                const intersects = raycaster.intersectObjects(beeModel.children, true);

                if (intersects.length > 0) {
                    // If the mouse is hovering over the bee and it's currently idle, trigger its movement
                    if (beeState === 'IDLE') {
                        startNewBeeMovement(3.7); // Hover-triggered movement is 1.6x faster
                    }
                    // Change the cursor to a pointer to indicate interactivity
                    document.body.style.cursor = 'pointer';
                } else {
                    // Revert the cursor to default when not hovering
                    document.body.style.cursor = 'default';
                }
            }

            if (beeMixer) {
                beeMixer.update(delta);
            }

            updateBeeBehavior(delta, elapsedTime);

            if (smokeGroup) {
                smokeMaterials.forEach(m => m.uniforms.uTime.value = elapsedTime);

                camera.getWorldDirection(cameraDirection);

                smokeGroup.children.forEach((plane, index) => {
                    if (smokeMaterials[index]) {
                        const worldNormal = planeNormal.clone().applyQuaternion(plane.getWorldQuaternion(new THREE.Quaternion()));
                        const dot = Math.abs(worldNormal.dot(cameraDirection));
                        smokeMaterials[index].uniforms.uOpacity.value = dot;
                    }
                });

                const smokeWorldPosition = new THREE.Vector3();
                smokeGroup.getWorldPosition(smokeWorldPosition);
                const angle = Math.atan2(
                    camera.position.x - smokeWorldPosition.x,
                    camera.position.z - smokeWorldPosition.z
                );
                smokeGroup.rotation.y = angle + THREE.MathUtils.degToRad(SMOKE_GROUP_ROTATION_DEGREES.y);
            }

            controls.update();
            renderer.render(scene, camera);
            cssRenderer.render(scene, camera);
        }

        // --- Other Event Listeners ---
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            loadGLBModel(url);
        });

        bgColorPicker.addEventListener('input', (event) => {
            const color = event.target.value;
            document.body.style.backgroundColor = color;

            const L = new THREE.Color(color).getHSL({ h: 0, s: 0, l: 0 }).l;
            const textColorClass = L > 0.5 ? 'text-gray-900' : 'text-white';
            const textSubtleColorClass = L > 0.5 ? 'text-gray-600' : 'text-gray-300';
            const codeBg = L > 0.5 ? 'bg-gray-200' : 'bg-gray-700';
            const codeText = L > 0.5 ? 'text-pink-600' : 'text-pink-400';
            const ishantTextColor = L > 0.5 ? 'text-black' : 'text-white';

            document.getElementById('title-text').className = `text-2xl font-bold ${textColorClass} drop-shadow-sm`;
            document.getElementById('instructions').className = `text-sm ${textSubtleColorClass} drop-shadow-sm max-w-sm`;
            document.getElementById('noise-opacity-label').className = `text-sm font-medium ${textSubtleColorClass}`;
            document.getElementById('noise-speed-slider').className = `text-sm font-medium ${textSubtleColorClass}`;
            document.getElementById('object-name-label').className = `text-sm font-medium ${textSubtleColorClass}`;
            document.getElementById('ishant-text').className = `text-9xl font-black ${ishantTextColor} opacity-10 select-none`;

            const codeText1 = document.getElementById('code-text-1');
            if (codeText1) {
                codeText1.className = `px-1 rounded-md ${codeBg} ${codeText}`;
            }
            const codeText2 = document.getElementById('code-text-2');
            if (codeText2) {
                codeText2.className = `px-1 rounded-md ${codeBg} ${codeText}`;
            }
        });

        // --- MODIFIED: Add event listeners for all ellipse controls ---
        document.getElementById('ellipse-color-picker').addEventListener('input', updateEllipseEffect);
        document.getElementById('ellipse-diameter-x-slider').addEventListener('input', updateEllipseEffect);
        document.getElementById('ellipse-diameter-y-slider').addEventListener('input', updateEllipseEffect);
        document.getElementById('ellipse-thickness-slider').addEventListener('input', updateEllipseEffect);
        document.getElementById('ellipse-softness-slider').addEventListener('input', updateEllipseEffect);
        document.getElementById('ellipse-offset-x-slider').addEventListener('input', updateEllipseEffect);
        document.getElementById('ellipse-offset-y-slider').addEventListener('input', updateEllipseEffect);


        noiseOpacitySlider.addEventListener('input', (event) => {
            noiseLayer.style.opacity = event.target.value;
        });

        noiseSpeedSlider.addEventListener('input', (event) => {
            noiseLayer.style.animationDuration = `${event.target.value}s`;
        });

        applyGlassBtn.addEventListener('click', () => {
            const targetName = objectNameInput.value;
            if (!loadedModel || !targetName) {
                showMessage('Please load a model and enter an object name first.', 'warning');
                return;
            }

            if (internalLight) {
                internalLight.parent.remove(internalLight);
                internalLight.dispose();
            }

            let objectFound = false;
            loadedModel.traverse((child) => {
                if (child.isMesh && child.name === targetName) {
                    objectFound = true;

                    const glassMaterial = new THREE.MeshPhysicalMaterial({
                        roughness: 0.1,
                        transmission: 1.0,
                        thickness: 1.5,
                        ior: 1.5,
                    });

                    child.material = glassMaterial;
                    internalLight = new THREE.PointLight(0xffe082, 5, 2);
                    child.add(internalLight);
                }
            });

            if (!objectFound) {
                showMessage(`Object with name "${targetName}" not found in the model.`, 'error');
            } else {
                showMessage(`Glass effect applied to "${targetName}".`, 'success');
            }
        });

        toggleUiBtn.addEventListener('click', () => {
            uiControlsContainer.classList.toggle('hidden');
            topLeftUi.classList.toggle('hidden');
            eyeIconOpen.classList.toggle('hidden');
            eyeIconClosed.classList.toggle('hidden');
        });

        window.addEventListener('keydown', (event) => {
            let targetKey = null;

            if (event.code === 'Space') {
                targetKey = spacebarKey;
                if (spacebarSound) {
                   spacebarSound.currentTime = 0;
                   spacebarSound.play().catch(e => console.log("Spacebar sound blocked:", e));
               }

            } else if (keyboardKeys.length > 0) {
                targetKey = keyboardKeys[Math.floor(Math.random() * keyboardKeys.length)];
                 playRandomKeypressSound();
            }

            if (targetKey && !gsap.isTweening(targetKey.position)) {
                const initialY = targetKey.position.y;
                const pressDepth = -0.05;

                gsap.timeline()
                    .to(targetKey.position, { y: initialY + pressDepth, duration: 0.1 })
                    .to(targetKey.position, { y: initialY, duration: 0.2, ease: "elastic.out(1, 0.5)" });
            }
        });

        // --- MODIFIED: Event listeners for the grid controls ---
        gridWidthSlider.addEventListener('input', updateCustomGrid);
        gridHeightSlider.addEventListener('input', updateCustomGrid);
        squareSizeSlider.addEventListener('input', updateCustomGrid);
        gridThicknessSlider.addEventListener('input', updateCustomGrid);
        gridColorPicker.addEventListener('input', updateCustomGrid);
        gridOffsetXSlider.addEventListener('input', updateCustomGrid);
        gridOffsetZSlider.addEventListener('input', updateCustomGrid);



        function startBootAnimationSequence() {

          /*  const bootSound = document.getElementById('boot-sound'); // Get the audio element
              if (bootSound) {
                  bootSound.play().catch(error => {
                      console.error("Error playing boot sound:", error);
                      // This catch block is important for handling Autoplay Policy issues.
                      // Browsers often prevent audio from playing automatically without user interaction.
                      // You might need to add a "play" button for the first interaction if this occurs.
                  });
              }*/


            // Start the blinking animation for the layer immediately.
            if (blinkingLayerObject) {
                blinkingLayerObject.visible = true;
                const blinkTl = gsap.timeline();
                const onDuration = 0.05;
                const totalOffDuration = BLINKING_LAYER_ANIMATION_DURATION - (BLINKING_LAYER_TOTAL_BLINKS * onDuration);

                let offDurations = [];
                for (let i = 0; i < BLINKING_LAYER_TOTAL_BLINKS; i++) {
                    const progress = i / (BLINKING_LAYER_TOTAL_BLINKS > 1 ? BLINKING_LAYER_TOTAL_BLINKS - 1 : 1);
                    const easeVal = 1 - gsap.parseEase("power1.in")(progress);
                    offDurations.push(easeVal);
                }

                const sumOfOffDurations = offDurations.reduce((a, b) => a + b, 0);
                if (sumOfOffDurations > 0) {
                    for (let i = 0; i < BLINKING_LAYER_TOTAL_BLINKS; i++) {
                        const normalizedOffDuration = (offDurations[i] / sumOfOffDurations) * totalOffDuration;
                        blinkTl.to(blinkingLayerObject.element.style, { opacity: 1, duration: onDuration })
                               .to(blinkingLayerObject.element.style, { opacity: 0, duration: normalizedOffDuration });
                    }
                }
                blinkTl.set(blinkingLayerObject.element.style, { opacity: 1 });
            }

            // Animate the iframe corners after a short delay.

                const iframe = cssObject.element;
                gsap.to(iframe.style, {
                    borderRadius: `${PLANE_CORNER_RADIUS_PX}px`,
                    duration: 0.05,
                    ease: BOOT_ANIMATION_EASING
                });


            // After a longer delay, trigger the final transition from boot state to initial state.
            setTimeout(() => {
                // Start fading out the black reveal layer.
                gsap.to(revealLayer, {
                    opacity: 0,
                    duration: 0.85,
                    ease: "power2.inOut",
                    onComplete: () => {
                        revealLayer.style.display = 'none';
                    }
                });

                // After one last small delay, run the main camera animation.
                setTimeout(() => {
                    animateFromBootToInitial();
                }, BOOT_STATE_DELAY); // 250ms

            }, 1200); // 1.2s
          }

          function precompile() {
            // renderer.compile tells Three.js to prepare all objects and materials
            // for rendering. It triggers the shader compilation on the GPU.
            renderer.compile(scene, camera);
            showMessage('Scene pre-compiled successfully.', 'success');
        }

        // --- UPDATED: loadGLBModel with new default light state ---
        function loadGLBModel(url) {
            gsap.set(revealLayer, { opacity: 1 });
            revealLayer.style.display = 'block';

            const loader = new GLTFLoader();
            instructions.textContent = 'Use your mouse to orbit (left-click), pan (right-click), and zoom (scroll).';

            loader.load(url,
                (gltf) => {
                    // --- Perform all heavy processing first, while revealLayer is visible ---
                    if (loadedModel) {
                        scene.remove(loadedModel);
                    }

                    loadedModel = gltf.scene;

                    // console.log("--- GLTF Model Objects ---");
                    loadedModel.traverse((child) => {
                        // console.log(`- Name: '${child.name}' (Type: ${child.type})`);
                    });
                    // console.log("--------------------------");

                    loadedModel.traverse((child) => {
                        if (child.isMesh && child.material && child.material.map) {
                            child.material.map.anisotropy = maxAnisotropy;
                            child.material.map.needsUpdate = true;
                        }
                    });
                    showMessage('Anisotropic filtering applied for sharper textures.', 'success');

                    keyboardKeys = [];
                    spacebarKey = null;
                    lottieHead = null;
                    lottieHeadPivot = null;
                    let cupBase = null;

                    loadedModel.traverse((child) => {
                        if (child.isGroup) {
                            if (child.name === "Lottiemon_Head") {
                                lottieHead = child;
                            }
                            if (child.name === "Cup_Base") {
                                cupBase = child;
                            }
                        }
                        if (child.isMesh) {
                            const match = child.name.match(/^Extruded(\d+)$/);
                            if (match) {
                                const keyNumber = parseInt(match[1], 10);
                                if (keyNumber >= 10 && keyNumber <= 36) {
                                    keyboardKeys.push(child);
                                }
                            } else if (child.name === 'Spacebar') {
                                spacebarKey = child;
                            }
                        }
                    });

                    if (lottieHead) {
                        showMessage('Lottiemon_Head found and enabled for wobble!', 'success');
                        const box = new THREE.Box3().setFromObject(lottieHead);
                        const center = box.getCenter(new THREE.Vector3());
                        const pivotPoint = new THREE.Vector3(center.x, box.min.y, center.z);

                        lottieHeadPivot = new THREE.Group();
                        lottieHeadPivot.position.copy(pivotPoint);

                        const parent = lottieHead.parent;
                        parent.add(lottieHeadPivot);

                        lottieHead.position.sub(pivotPoint);
                        lottieHeadPivot.add(lottieHead);
                    } else {
                        showMessage('Lottiemon_Head not found in this model.', 'warning');
                    }

                    if (cupBase) {
                        showMessage('Cup_Base found! Adding smoke and coffee.', 'success');
                        createSmokeEffect(cupBase);
                        createCoffeePlane(cupBase);
                    } else {
                        showMessage('Cup_Base not found in this model.', 'warning');
                    }

                    const flowerVas = loadedModel.getObjectByName('Flower_Vas');
                    if (flowerVas) {
                        showMessage('Flower_Vas found! Loading the bee model.', 'success');
                        const vasPosition = new THREE.Vector3();
                        flowerVas.getWorldPosition(vasPosition);
                        loadBeeModel(vasPosition);
                    } else {
                        showMessage('Flower_Vas object not found. The bee will not be loaded.', 'warning');
                    }

                    // --- Find the 86body group and its lights material ---
                    loadedModel.traverse((child) => {
                        // Find the body group by its name
                        if (child.isGroup && child.name === '86body' && !body86) {
                            body86 = child;
                            body86.position.add(BODY86_POSITION_OFFSET); // Apply position offset
                            body86InitialY = child.position.y; // Store its starting Y position
                            // console.log('Found group: 86body', body86);
                            createGroundLights(body86); // NEW: Create ground lights once body is found
                        }

                        // Find the lights material by its name
                        if (child.isMesh && child.material && child.material.name === '86Lights' && !lights86Material) {
                            // Clone the material so our changes don't affect other objects
                            lights86Material = child.material.clone();
                            child.material = lights86Material;

                            // Set up the material for emission
                            lights86Material.emissive = new THREE.Color(BODY86_LIGHT_EMISSIVE_COLOR);

                            // --- UPDATED: Set the default "off" state ---
                            lights86Material.emissiveIntensity = 0.1;
                            lights86Material.color.set(BODY86_LIGHT_BASE_COLOR);

                            // console.log('Found and configured material: 86Lights');
                        }
                    });

                    scene.add(loadedModel);

                    precompile();

                    const box = new THREE.Box3().setFromObject(loadedModel);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    const maxDim = Math.max(size.x, size.y, size.z);

                    camera.near = maxDim * NEAR_PLANE_MULTIPLIER;
                    camera.far = maxDim * FAR_PLANE_MULTIPLIER;
                    camera.updateProjectionMatrix();

                    const pannedTarget = center.clone();
                    pannedTarget.x += INITIAL_CAMERA_PAN_X;
                    pannedTarget.y += INITIAL_CAMERA_PAN_Y;

                    initialCameraState.target.copy(pannedTarget);
                    initialCameraState.position.copy(pannedTarget.clone().add(INITIAL_CAMERA_POSITION));

                    const degToRad = Math.PI / 180;
                    const initialAzimuth = controls.getAzimuthalAngle();
                    const initialPolar = controls.getPolarAngle();
                    initialControlLimits = {
                        minAzimuth: initialAzimuth - (ORBIT_LIMIT_LEFT * degToRad),
                        maxAzimuth: initialAzimuth + (ORBIT_LIMIT_RIGHT * degToRad),
                        minPolar: initialPolar - (ORBIT_LIMIT_UP * degToRad),
                        maxPolar: initialPolar + (ORBIT_LIMIT_DOWN * degToRad),
                        minZoom: INITIAL_MIN_ZOOM,
                        maxZoom: INITIAL_MAX_ZOOM
                    };

                    // console.group("Camera Animation States & Calculated Values");
                    // console.log("%cBoot State (Starting View):", "color: cyan; font-weight: bold;");
                    // console.log("  Camera Position:", camera.position.clone());
                    // console.log("  Controls Target:", controls.target.clone());
                    // console.log("  Camera Zoom:", camera.zoom);
                    // console.groupEnd();

                    isInBootState = true;
                    controls.enabled = false;

                    const iframe = cssObject.element;
                    if (iframe && iframe.contentWindow) {
                        //iframe.contentWindow.postMessage('captureScreenshot', '*');
                        if(boot_sequence_finished){
                          iframe.contentWindow.postMessage('boot_complete', '*');
                          startBootAnimationSequence();

                          }
                        // console.log("Requested initial screenshot from iframe for boot sequence.");
                    } else {
                        // console.error("Cannot access iframe contentWindow to request initial screenshot.");
                        createFallbackPlaceholder();
                    }



                    URL.revokeObjectURL(url);
                },
                undefined,
                (error) => {
                    // console.error('An error happened while loading the model:', error);
                    showMessage('Error loading model. Check console for details.', 'error');
                    gsap.to(revealLayer, { opacity: 0, duration: 0.5, onComplete: () => { revealLayer.style.display = 'none'; }});
                }
            );
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraFrustum();
        });

        init();

    </script>
</body>
</html>
